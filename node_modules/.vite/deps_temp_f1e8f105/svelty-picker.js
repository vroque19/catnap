import {
  fade
} from "./chunk-FIXQMT7Y.js";
import "./chunk-K7767AIO.js";
import {
  cubicOut
} from "./chunk-YERFD2CZ.js";
import {
  action,
  add_locations,
  append_styles,
  bind_prop,
  bind_this,
  bubble_event,
  check_target,
  cleanup_styles,
  createEventDispatcher,
  each,
  hmr,
  if_block,
  index,
  init,
  legacy_api,
  onMount,
  prop,
  remove_input_defaults,
  set_attribute,
  set_class,
  set_value,
  slot,
  toggle_class,
  transition,
  validate_each_keys
} from "./chunk-UBUR6AJL.js";
import {
  append,
  comment,
  preventDefault,
  set_text,
  template
} from "./chunk-B5GM3TBI.js";
import {
  FILENAME,
  HMR,
  apply,
  child,
  deep_read_state,
  derived,
  derived_safe_equal,
  effect,
  equals,
  event,
  first_child,
  get,
  invalidate_inner_signals,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_state,
  mutate,
  next,
  pop,
  push,
  reset,
  set,
  sibling,
  strict_equals,
  template_effect,
  tick,
  update
} from "./chunk-7G4UXERQ.js";
import "./chunk-3IAHEC54.js";
import "./chunk-UGBVNEQM.js";

// node_modules/svelty-picker/dist/i18n/index.js
var en = {
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
  daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
  daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  meridiem: ["am", "pm"],
  suffix: ["st", "nd", "rd", "th"],
  todayBtn: "Today",
  clearBtn: "Clear",
  okBtn: "Ok",
  cancelBtn: "Cancel",
  timeView: "Show time view",
  backToDate: "Back to calendar view"
};

// node_modules/svelty-picker/dist/settings.js
var settings_default = {
  theme: "sdt-calendar-colors",
  format: "yyyy-mm-dd",
  formatType: "standard",
  displayFormat: null,
  displayFormatType: null,
  minuteIncrement: 1,
  weekStart: 1,
  inputClasses: "",
  todayBtnClasses: "sdt-action-btn sdt-today-btn",
  clearBtnClasses: "sdt-action-btn sdt-clear-btn",
  hourOnly: false,
  todayBtn: true,
  clearBtn: true,
  clearToggle: true,
  autocommit: true,
  i18n: en
};

// node_modules/svelty-picker/dist/utils/constants.js
var MODE_DECADE = 0;
var MODE_YEAR = 1;
var MODE_MONTH = 2;
var STARTVIEW_TIME = 3;

// node_modules/svelty-picker/dist/utils/dateUtils.js
function parseDate(date, format, i18n, type) {
  var _a, _b;
  if (date instanceof Date) {
    return date;
  }
  const commonFormats = type === "php" ? { date: "Y-m-d", datetime: "Y-m-d H:i", datetime_s: "Y-m-d H:i:s" } : { date: "yyyy-mm-dd", datetime: "yyyy-mm-dd hh:ii", datetime_s: "yyyy-mm-dd hh:ii:ss" };
  let parsedFormat;
  let useParsedTime;
  if (/^\d{4}\-\d{1,2}\-\d{1,2}$/.test(date)) {
    parsedFormat = formatHelper.parseFormat(commonFormats.date, type);
  } else if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}$/.test(date)) {
    parsedFormat = formatHelper.parseFormat(commonFormats.datetime, type);
  } else if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}\:\d{1,2}[Z]{0,1}$/.test(date)) {
    parsedFormat = formatHelper.parseFormat(commonFormats.datetime_s, type);
  } else if (/^([01]*\d|2[0-3])([0-5]\d)(?:[ ]([ap][m]|[AP][M]))?$/.test(date)) {
    useParsedTime = (_a = date.match(/^([01]*\d|2[0-3])([0-5]\d)(?:[ ]([ap][m]|[AP][M]))?$/)) == null ? void 0 : _a.slice(1).filter((e) => e);
    parsedFormat = formatHelper.parseFormat(format, type);
  } else {
    parsedFormat = formatHelper.parseFormat(format, type);
  }
  const parts = useParsedTime ? useParsedTime : date && date.toString().match(formatHelper.nonpunctuation) || [];
  date = /* @__PURE__ */ new Date();
  date.setHours(0, 0, 0, 0);
  const parsed = {};
  const { setters_order, setters_map } = formatHelper.setters(type);
  let val, part;
  if (parts.length !== parsedFormat.parts.length && parsedFormat.parts.includes("S")) {
    const splitSuffix = (_b = parts[parsedFormat.parts.indexOf("S") - 1].match(/(\d+)([a-zA-Z]+)/)) == null ? void 0 : _b.slice(1, 3);
    parts.splice(parsedFormat.parts.indexOf("S") - 1, 1, ...splitSuffix);
  }
  if (parts.length === parsedFormat.parts.length) {
    for (var i = 0, cnt = parsedFormat.parts.length; i < cnt; i++) {
      val = parseInt(parts[i], 10);
      part = parsedFormat.parts[i];
      if (isNaN(val)) {
        if (type === "standard") {
          switch (part) {
            case "MM":
              val = i18n.months.indexOf(parts[i]) + 1;
              break;
            case "M":
              val = i18n.monthsShort.indexOf(parts[i]) + 1;
              break;
            case "p":
            case "P":
              val = i18n.meridiem.indexOf(parts[i].toLowerCase());
              break;
          }
        } else {
          switch (part) {
            case "D":
              val = i18n.daysShort.indexOf(parts[i]) + 1;
              break;
            case "l":
              val = i18n.days.indexOf(parts[i]) + 1;
              break;
            case "F":
              val = i18n.months.indexOf(parts[i]) + 1;
              break;
            case "M":
              val = i18n.monthsShort.indexOf(parts[i]) + 1;
              break;
            case "a":
            case "A":
              val = i18n.meridiem.indexOf(parts[i].toLowerCase());
              break;
          }
        }
      }
      parsed[part] = val;
    }
    for (var i = 0, s; i < setters_order.length; i++) {
      s = setters_order[i];
      if (s in parsed && !isNaN(parsed[s]))
        setters_map[`${s}`] && setters_map[`${s}`](date, parsed[s]);
    }
  }
  return date;
}
function formatDate(date, format, i18n, type) {
  var _a;
  if (date === null) {
    return "";
  }
  const dateVal = date.getDate();
  let val;
  if (type === "standard") {
    val = {
      t: date.getTime(),
      // year
      yy: date.getFullYear().toString().substring(2),
      yyyy: date.getFullYear(),
      // month
      m: date.getMonth() + 1,
      M: i18n.monthsShort[date.getMonth()],
      MM: i18n.months[date.getMonth()],
      // day
      d: dateVal,
      D: i18n.daysShort[date.getDay()],
      DD: i18n.days[date.getDay()],
      S: dateVal % 10 && dateVal % 10 < 4 && (dateVal < 10 || dateVal > 14) ? i18n.suffix[dateVal % 10 - 1] : i18n.suffix[i18n.suffix.length - 1],
      p: i18n.meridiem.length === 2 ? i18n.meridiem[date.getHours() < 12 ? 0 : 1] : "",
      // hour
      h: date.getHours(),
      // minute
      ii: (date.getMinutes() < 10 ? "0" : "") + date.getMinutes(),
      // second
      ss: (date.getUTCSeconds() < 10 ? "0" : "") + date.getUTCSeconds()
    };
    if (i18n.meridiem.length === 2) {
      val.H = val.h % 12 === 0 ? 12 : val.h % 12;
    } else {
      val.H = val.h;
    }
    val.HH = (val.H < 10 ? "0" : "") + val.H;
    val.P = val.p.toUpperCase();
    val.hh = (val.h < 10 ? "0" : "") + val.h;
    val.i = val.ii;
    val.s = val.ss;
    val.dd = (val.d < 10 ? "0" : "") + val.d;
    val.mm = (val.m < 10 ? "0" : "") + val.m;
  } else if (type === "php") {
    val = {
      // year
      y: date.getFullYear().toString().substring(2),
      Y: date.getFullYear(),
      // month
      F: i18n.months[date.getMonth()],
      M: i18n.monthsShort[date.getMonth()],
      n: date.getMonth() + 1,
      t: getDaysInMonth(date.getFullYear(), date.getMonth()),
      // day
      j: date.getDate(),
      l: i18n.days[date.getDay()],
      D: i18n.daysShort[date.getDay()],
      w: date.getDay(),
      // 0 -> 6
      N: date.getDay() === 0 ? 7 : date.getDay(),
      // 1 -> 7
      S: dateVal % 10 && dateVal % 10 < 4 && (dateVal < 10 || dateVal > 14) ? i18n.suffix[dateVal % 10 - 1] : i18n.suffix[i18n.suffix.length - 1],
      // hour
      a: i18n.meridiem.length === 2 ? i18n.meridiem[date.getHours() < 12 ? 0 : 1] : "",
      g: date.getHours() % 12 === 0 ? 12 : date.getHours() % 12,
      G: date.getHours(),
      // minute
      i: date.getMinutes(),
      // second
      s: date.getSeconds(),
      U: Math.floor(date.getTime() / 1e3)
    };
    val.m = (val.n < 10 ? "0" : "") + val.n;
    val.d = (val.j < 10 ? "0" : "") + val.j;
    val.A = val.a.toString().toUpperCase();
    val.h = (val.g < 10 ? "0" : "") + val.g;
    val.H = (val.G < 10 ? "0" : "") + val.G;
    val.i = (val.i < 10 ? "0" : "") + val.i;
    val.s = (val.s < 10 ? "0" : "") + val.s;
  } else {
    throw new Error("Invalid format type.");
  }
  let dateArr = [];
  const pFormat = formatHelper.parseFormat(format, type);
  for (var i = 0, cnt = ((_a = pFormat.parts) == null ? void 0 : _a.length) || 0; i < cnt; i++) {
    if (pFormat.separators.length) {
      dateArr.push(pFormat.separators.shift());
    }
    dateArr.push(val[pFormat.parts[i]]);
  }
  if (pFormat.separators.length) {
    dateArr.push(pFormat.separators.shift());
  }
  return dateArr.join("");
}
function getDaysInMonth(year, month) {
  const isLeapYear = year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  return [31, isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
}
var formatHelper = {
  validParts: function(type) {
    if (type === "standard") {
      return /t|hh?|HH?|p|P|z|ii?|ss?|dd?|DD?|S|mm?|MM?|yy(?:yy)?/g;
    } else if (type === "php") {
      return /[dDjlNwzFmMnStyYaABgGhHisU]/g;
    } else {
      throw new Error("Invalid format type.");
    }
  },
  nonpunctuation: /[^ -\/:-@\[-`{-~\t\n\rTZ]+/g,
  /**
   *
   * @param {string} format
   * @param {string} type
   * @returns {{ separators: string[], parts: string[]} }
   */
  parseFormat: function(format, type) {
    var separators = format.replace(this.validParts(type), "\0").split("\0"), parts = format.match(this.validParts(type)) || [];
    if (!separators || !separators.length || !parts || parts.length === 0) {
      console.warn("invalid date format", separators, parts);
    }
    return { separators, parts };
  },
  /**
   * @param {string} type
   * @returns {{setters_map: SetterMap, setters_order: string[]}}
   */
  setters: function(type) {
    let setters_order;
    let setters_map = {};
    if (type === "standard") {
      setters_order = ["yyyy", "yy", "m", "mm", "M", "MM", "d", "dd", "D", "DD", "hh", "h", "HH", "H", "ii", "i", "ss", "s", "S", "p", "P", "t"];
      setters_map = {
        hh: (d, v) => d.setHours(v),
        h: (d, v) => d.setHours(v),
        HH: (d, v) => d.setHours(v === 12 ? 0 : v),
        H: (d, v) => d.setHours(v === 12 ? 0 : v),
        i: (d, v) => d.setMinutes(v),
        s: (d, v) => d.setSeconds(v),
        yyyy: (d, v) => d.setFullYear(v),
        yy: (d, v) => d.setFullYear((v < 50 ? 2e3 : 1900) + v),
        m: (d, v) => {
          v -= 1;
          while (v < 0) v += 12;
          v %= 12;
          d.setMonth(v);
          while (d.getMonth() !== v)
            if (isNaN(d.getMonth()))
              return d;
            else
              d.setDate(d.getDate() - 1);
          return d;
        },
        d: (d, v) => d.setDate(v),
        p: (d, v) => d.setHours(v === 1 && d.getHours() < 12 ? d.getHours() + 12 : d.getHours()),
        t: (d, v) => d.setTime(v),
        mm: () => {
        },
        M: () => {
        },
        MM: () => {
        },
        ii: () => {
        },
        ss: () => {
        },
        dd: () => {
        },
        D: () => {
        },
        DD: () => {
        },
        P: () => {
        }
      };
      setters_map.mm = setters_map.M = setters_map.MM = setters_map.m;
      setters_map.ii = setters_map.i;
      setters_map.ss = setters_map.s;
      setters_map.dd = setters_map.D = setters_map.DD = setters_map.d;
      setters_map.P = setters_map.p;
    } else {
      setters_order = ["Y", "yy", "m", "M", "F", "n", "d", "D", "j", "l", "N", "S", "H", "G", "h", "g", "i", "s", "p", "P", "U"];
      setters_map = {
        H: (d, v) => d.setHours(v),
        G: (d, v) => d.setHours(v),
        h: (d, v) => d.setHours(v === 12 ? 0 : v),
        g: (d, v) => d.setHours(v === 12 ? 0 : v),
        i: (d, v) => d.setMinutes(v),
        s: (d, v) => d.setSeconds(v),
        Y: (d, v) => d.setFullYear(v),
        yy: (d, v) => d.setFullYear((v < 50 ? 2e3 : 1900) + v),
        m: (d, v) => {
          v -= 1;
          while (v < 0) v += 12;
          v %= 12;
          d.setMonth(v);
          while (d.getMonth() !== v)
            if (isNaN(d.getMonth()))
              return d;
            else
              d.setDate(d.getDate() - 1);
          return d;
        },
        n: (d, v) => d.setMonth(v - 1),
        d: (d, v) => d.setDate(v),
        a: (d, v) => d.setHours(v === 1 ? d.getHours() + 12 : d.getHours()),
        U: (d, v) => d.setTime(v * 1e3)
      };
      setters_map.F = setters_map.M = setters_map.m;
      setters_map.D = setters_map.j = setters_map.l = setters_map.N = setters_map.d;
      setters_map.A = setters_map.a;
    }
    return { setters_order, setters_map };
  }
};

// node_modules/svelty-picker/dist/utils/grid.js
function compute(currentDate, selectedDates, view, locale, weekStart) {
  if (view === MODE_DECADE) {
    let prevTo2 = 10;
    let nextFrom2 = 20;
    const todayMark2 = -1;
    const grid2 = [];
    let yearRow = [];
    let currYear = currentDate.getFullYear() - currentDate.getFullYear() % 10;
    currYear -= currYear % 20 ? 12 : 10;
    if (currYear % 10) {
      prevTo2 = 12;
      nextFrom2 = 22;
    }
    for (let i = 0; i < 32; i++) {
      yearRow.push(currYear + i);
      if (yearRow.length === 4) {
        grid2.push(yearRow);
        yearRow = [];
      }
    }
    let selectionMark2 = [];
    if (!selectedDates[0]) {
      selectedDates[0] = /* @__PURE__ */ new Date();
    }
    if (selectedDates[0].getFullYear() >= currYear) {
      selectionMark2.push(selectedDates[0].getFullYear() % currYear);
    }
    return {
      years: grid2,
      todayMark: todayMark2,
      nextFrom: nextFrom2,
      prevTo: prevTo2,
      selectionMark: selectionMark2
    };
  }
  if (view === MODE_YEAR) {
    let grid2 = [];
    let monthRow = [];
    let prevTo2 = 12;
    let nextFrom2 = 24;
    const ISO = currentDate.toISOString().split("T")[0].substring(0, 8);
    const dateNormalized = /* @__PURE__ */ new Date(ISO + "01 00:00:00");
    const initYear = dateNormalized.getFullYear() - 1;
    dateNormalized.setFullYear(initYear);
    let todayMark2 = 0;
    for (let y2 = 0; y2 < 3; y2++) {
      for (let i = 0; i < 12; i++) {
        dateNormalized.setMonth(i);
        monthRow.push(locale.monthsShort[i % 12]);
        if (monthRow.length === 4) {
          grid2.push(monthRow);
          monthRow = [];
        }
      }
      dateNormalized.setFullYear(dateNormalized.getFullYear() + 1);
    }
    let selectionMark2 = [];
    if (!selectedDates[0]) {
      selectedDates[0] = /* @__PURE__ */ new Date();
    }
    if (selectedDates[0].getFullYear() - initYear >= 0 && selectedDates[0].getFullYear() - initYear <= 2) {
      selectionMark2.push(selectedDates[0].getMonth() + (selectedDates[0].getFullYear() - initYear || 0) * 12);
    }
    return {
      months: grid2,
      todayMark: todayMark2,
      nextFrom: nextFrom2,
      prevTo: prevTo2,
      selectionMark: selectionMark2
    };
  }
  let d = currentDate || /* @__PURE__ */ new Date(), y = d.getFullYear(), m = d.getMonth(), dM = d.getDate(), h = d.getHours(), today = /* @__PURE__ */ new Date();
  let prevMonth = new Date(y, m - 1, 28, 0, 0, 0, 0), day = getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
  prevMonth.setDate(day);
  prevMonth.setDate(day - (prevMonth.getDay() - weekStart + 7) % 7);
  let nextMonth = new Date(prevMonth);
  nextMonth.setDate(nextMonth.getDate() + 42);
  let nextMonthValue = nextMonth.valueOf();
  let grid = [];
  let dayRow = [];
  let todayMark = -1;
  let selectionMark = [];
  let prevTo = 0;
  let nextFrom = 42;
  let inc = 0;
  while (prevMonth.valueOf() < nextMonthValue) {
    inc++;
    dayRow.push(new Date(prevMonth));
    if (prevMonth.getFullYear() < y || prevMonth.getFullYear() === y && prevMonth.getMonth() < m) {
      prevTo = inc;
    } else if (nextFrom === 42 && (prevMonth.getFullYear() > y || prevMonth.getFullYear() === y && prevMonth.getMonth() > m)) {
      nextFrom = inc - 1;
    }
    prevMonth.setDate(prevMonth.getDate() + 1);
    if (prevMonth.getFullYear() === today.getFullYear() && prevMonth.getMonth() === today.getMonth() && prevMonth.getDate() === today.getDate()) {
      todayMark = inc;
    }
    if (selectionMark.length !== selectedDates.length) {
      selectedDates.map((s) => {
        if (prevMonth.getFullYear() === s.getFullYear() && prevMonth.getMonth() === s.getMonth() && prevMonth.getDate() === s.getDate())
          selectionMark.push(inc);
      });
    }
    if (dayRow.length === 7) {
      grid.push(dayRow);
      dayRow = [];
    }
  }
  return {
    grid,
    days: grid,
    todayMark,
    prevTo,
    nextFrom,
    selectionMark
  };
}

// node_modules/svelty-picker/dist/utils/transitions.js
function scale(node, { duration = 400, start = 0, end = 1, opacity = 0 }) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const sd = 1 - start;
  const od = target_opacity * (1 - opacity);
  end = end || 1;
  return {
    delay: 0,
    duration,
    easing: cubicOut,
    css: (_t, u) => `
        transform: ${transform} scale(${end !== 1 ? start + end * u : 1 - sd * u});
        opacity: ${target_opacity - od * u};
      `
  };
}

// node_modules/svelty-picker/dist/components/Calendar.svelte
mark_module_start();
Calendar[FILENAME] = "node_modules/svelty-picker/dist/components/Calendar.svelte";
var root_1 = add_locations(template(`<button type="button" class="std-btn std-btn-header icon-btn sdt-time-icon s-mEMfzfAXZadf"><svg class="sdt-svg s-mEMfzfAXZadf" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0zM8 0a8 8 0 100 16A8 8 0 008 0zm.5 4.75a.75.75 0 00-1.5 0v3.5a.75.75 0 00.471.696l2.5 1a.75.75 0 00.557-1.392L8.5 7.742V4.75z"></path></svg></button>`), Calendar[FILENAME], [
  [
    359,
    2,
    [[360, 4, [[360, 103]]]]
  ]
]);
var root_4 = add_locations(template(`<td class="sdt-cal-td s-mEMfzfAXZadf"><button type="button" class="std-btn s-mEMfzfAXZadf"> </button></td>`), Calendar[FILENAME], [[388, 8, [[389, 10]]]]);
var root_3 = add_locations(template(`<tr class="sdt-cal-td s-mEMfzfAXZadf"></tr>`), Calendar[FILENAME], [[385, 6]]);
var root_2 = add_locations(template(`<table class="sdt-table s-mEMfzfAXZadf" style="max-height: 221px; height: 221px"><tbody class="sdt-tbody-lg s-mEMfzfAXZadf"></tbody></table>`), Calendar[FILENAME], [[378, 2, [[379, 4]]]]);
var root_7 = add_locations(template(`<td class="sdt-cal-td s-mEMfzfAXZadf"><button class="std-btn s-mEMfzfAXZadf" type="button"> </button></td>`), Calendar[FILENAME], [[412, 8, [[413, 10]]]]);
var root_6 = add_locations(template(`<tr class="sdt-cal-td s-mEMfzfAXZadf"></tr>`), Calendar[FILENAME], [[409, 6]]);
var root_5 = add_locations(template(`<table class="sdt-table s-mEMfzfAXZadf"><tbody class="sdt-tbody-lg s-mEMfzfAXZadf"></tbody></table>`), Calendar[FILENAME], [[403, 2, [[404, 4]]]]);
var root_9 = add_locations(template(`<th class="sdt-cal-th s-mEMfzfAXZadf"> </th>`), Calendar[FILENAME], [[430, 8]]);
var root_11 = add_locations(template(`<td class="sdt-cal-td s-mEMfzfAXZadf"><button type="button" class="std-btn sdt-btn-day s-mEMfzfAXZadf"> </button></td>`), Calendar[FILENAME], [[439, 8, [[447, 10]]]]);
var root_10 = add_locations(template(`<tr></tr>`), Calendar[FILENAME], [[434, 6]]);
var root_8 = add_locations(template(`<table class="sdt-table sdt-table-height s-mEMfzfAXZadf"><tbody><tr class="sdt-cal-td s-mEMfzfAXZadf"></tr><!></tbody></table>`), Calendar[FILENAME], [
  [
    426,
    2,
    [[427, 4, [[428, 6]]]]
  ]
]);
var root = add_locations(template(`<div class="sdt-thead-nav s-mEMfzfAXZadf"><button type="button" class="std-btn std-btn-header sdt-toggle-btn s-mEMfzfAXZadf"> </button> <!> <button type="button" class="std-btn std-btn-header icon-btn s-mEMfzfAXZadf"><svg class="sdt-svg s-mEMfzfAXZadf" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="24" height="24"><path d="M4.427 9.573l3.396-3.396a.25.25 0 01.354 0l3.396 3.396a.25.25 0 01-.177.427H4.604a.25.25 0 01-.177-.427z"></path></svg></button> <button type="button" class="std-btn std-btn-header icon-btn s-mEMfzfAXZadf"><svg class="sdt-svg s-mEMfzfAXZadf" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="24" height="24"><path d="M4.427 7.427l3.396 3.396a.25.25 0 00.354 0l3.396-3.396A.25.25 0 0011.396 7H4.604a.25.25 0 00-.177.427z"></path></svg></button> <div class="sdt-nav-btns s-mEMfzfAXZadf"></div></div> <div class="sdt-calendar s-mEMfzfAXZadf"><!> <!> <!></div>`, 1), Calendar[FILENAME], [
  [
    356,
    0,
    [
      [357, 2],
      [
        363,
        2,
        [[366, 4, [[366, 103]]]]
      ],
      [
        368,
        2,
        [[371, 4, [[371, 103]]]]
      ],
      [373, 2]
    ]
  ],
  [376, 0]
]);
var $$css = {
  hash: "s-mEMfzfAXZadf",
  code: "\n  td.s-mEMfzfAXZadf,th.s-mEMfzfAXZadf {\n    padding: 0;\n    border-width: 0;\n  }\n.sdt-cal-td.s-mEMfzfAXZadf {\n  padding: 0;\n  font-size: 90%;\n  text-align: center;\n  /* background-color: var(--sdt-bg-main, #fff); */\n}\n.sdt-cal-th.s-mEMfzfAXZadf {\n  text-align: center;\n  height: 24px;\n}\n.sdt-calendar.s-mEMfzfAXZadf {\n  height: 221px;\n  overflow: hidden;\n}\n.sdt-calendar.is-grid.s-mEMfzfAXZadf {\n  display: grid;\n}\n.sdt-calendar.is-grid.s-mEMfzfAXZadf .sdt-table:where(.s-mEMfzfAXZadf) {\n  grid-column: 1/2;\n  grid-row: 1/2;\n}\n.sdt-table.s-mEMfzfAXZadf {\n  width: 100%;\n  border-collapse: collapse;\n  margin: 0;\n  background-color: var(--sdt-table-bg, transparent);\n}\n.sdt-table-height.s-mEMfzfAXZadf {\n  height: 222px;\n}\n.animate-transition.s-mEMfzfAXZadf {\n  will-change: transform;\n  transition: transform .3s ease;\n}\n.not-current.s-mEMfzfAXZadf {\n  opacity: 0.3;\n}\n.not-current.s-mEMfzfAXZadf:hover {\n  opacity: 0.55;\n}\n.std-btn.s-mEMfzfAXZadf {\n  margin: 0;\n  border: 0;\n  background: transparent;\n  text-align: center;\n  width: 100%;\n  border-radius: 4px;\n  cursor: pointer;\n  padding: 0.3rem;\n  box-sizing: border-box;\n  color: var(--sdt-color, initial);\n}\n.sdt-btn-day.s-mEMfzfAXZadf {\n  max-height: 32px;\n  height: 32px;\n}\n.std-btn[disabled].s-mEMfzfAXZadf {\n  cursor: not-allowed;\n  opacity: 0.5;\n  color: var(--sdt-table-disabled-date, #b22222);\n  background-color: var(--sdt-table-disabled-date-bg, var(--sdt-bg-main, #fff));\n}\n.std-btn-header.s-mEMfzfAXZadf {\n  width: auto;\n  font-weight: bold;\n  padding: 0.375em 0.5em;\n  color: var(--sdt-header-color, var(--sdt-color, initial));\n}\n.std-btn-header.icon-btn.s-mEMfzfAXZadf:first-of-type {\n  padding-left: 0.375em;\n  padding-right: 0.375em;\n}\n.std-btn-header.icon-btn.s-mEMfzfAXZadf {\n  padding-left: 0.25em;\n  padding-right: 0.25em;\n}\n.std-btn.s-mEMfzfAXZadf:hover {\n  background-color: var(--sdt-table-data-bg-hover, #eee);\n}\n.is-selected.in-range.s-mEMfzfAXZadf .std-btn:where(.s-mEMfzfAXZadf) {\n  border-radius: 4px 0 0 4px\n}\n.in-range.s-mEMfzfAXZadf .std-btn:where(.s-mEMfzfAXZadf) /* (unused) .in-range-hover:not(.is-selected) .std-btn*/ {\n  background-color: color-mix(in srgb, transparent 75%, var(--sdt-bg-selected, #286090));\n  border-radius: 0;\n}\n/* range selection: start */\n/* (unused) .in-range-hover.is-selected:has(+ .in-range-hover) .std-btn {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}*/\n.in-range-hover.s-mEMfzfAXZadf + .in-range-hover.is-selected:where(.s-mEMfzfAXZadf) .std-btn:where(.s-mEMfzfAXZadf) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n/* (unused) .in-range:not(.is-selected) .std-btn:hover {\n  background-color: color-mix(in srgb, var(--sdt-table-data-bg-hover, #eee) 75%, var(--sdt-bg-selected, #286090));\n}*/\n/* range selection: end */\n.in-range.s-mEMfzfAXZadf + .is-selected:where(.s-mEMfzfAXZadf) .std-btn:where(.s-mEMfzfAXZadf),\n.is-selected.s-mEMfzfAXZadf + .is-selected:where(.s-mEMfzfAXZadf) .std-btn:where(.s-mEMfzfAXZadf) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.is-selected.s-mEMfzfAXZadf + .is-selected:where(.s-mEMfzfAXZadf) .std-btn:where(.s-mEMfzfAXZadf) {\n  border-left: 1px solid color-mix(in srgb, white 75%, var(--sdt-table-selected-bg, var(--sdt-bg-selected, #286090)));\n  margin-left: -1px;\n}\n.is-selected.s-mEMfzfAXZadf .std-btn:where(.s-mEMfzfAXZadf),\n.is-selected.in-range.s-mEMfzfAXZadf .std-btn:where(.s-mEMfzfAXZadf) {\n  background-color: var(--sdt-table-selected-bg, var(--sdt-bg-selected, #286090));\n  color: var(--sdt-color-selected, var(--sdt-bg-main, #fff));\n  opacity: 0.9;\n}\n.std-btn-header.s-mEMfzfAXZadf:hover {\n  background-color: var(--sdt-header-btn-bg-hover, #dfdfdf);\n}\n.sdt-time-icon.s-mEMfzfAXZadf {\n  display: inline-flex;\n  align-items: center;\n  padding: 0.375em !important;\n}\n.sdt-time-icon.s-mEMfzfAXZadf svg:where(.s-mEMfzfAXZadf) {\n  height: 1em !important;\n  stroke: initial !important;\n}\n.sdt-tbody-lg.s-mEMfzfAXZadf {\n  background-color: var(--sdt-bg-main, #fff);\n}\n.sdt-tbody-lg.s-mEMfzfAXZadf .std-btn:where(.s-mEMfzfAXZadf) {\n  height: 74px;\n}\n.sdt-thead-nav.s-mEMfzfAXZadf {\n  display: flex;\n  margin-bottom: 0.25em;\n  align-items: stretch;\n}\n.sdt-nav-btns.s-mEMfzfAXZadf {\n  white-space: nowrap;\n}\n.sdt-toggle-btn.s-mEMfzfAXZadf {\n  width: 100%;\n  text-align: left;\n}\n.sdt-today.s-mEMfzfAXZadf {\n  position: relative;\n}\n.sdt-today.s-mEMfzfAXZadf:before {\n  box-sizing: border-box;\n  position: absolute;\n  content: '';\n  margin-left: 4px;\n  margin-top: 4px;\n  border-left: 4px solid var(--sdt-table-today-indicator, #ccc);\n  border-top: 4px solid var(--sdt-table-today-indicator, #ccc);\n  border-bottom: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-radius: 2px;\n  height: 4px;\n  z-index: 2;\n}\n.sdt-svg.s-mEMfzfAXZadf {\n  fill: var(--sdt-header-color, initial);\n}\n.sdt-today.s-mEMfzfAXZadf:hover:before,\n.in-range.sdt-today.s-mEMfzfAXZadf:before {\n  border-left-color: var(--sdt-bg-selected, #286090);\n  border-top-color: var(--sdt-bg-selected, #286090);\n}\n.is-selected.sdt-today.s-mEMfzfAXZadf:before\n {\n  border-left-color: #eee;\n  border-top-color: #eee;\n}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkNhbGVuZGFyLnN2ZWx0ZSJdfQ== */"
};
function Calendar($$anchor, $$props) {
  var _a;
  check_target(new.target);
  push($$props, false, Calendar);
  append_styles($$anchor, $$css);
  const computedStartDate = mutable_state();
  const start = mutable_state();
  const end = mutable_state();
  const swapTransition = mutable_state();
  const times = mutable_state();
  const dataset = mutable_state();
  const dayLabels = mutable_state();
  const tableCaption = mutable_state();
  let wid = prop($$props, "wid", 8);
  let dates = prop($$props, "dates", 8);
  let startDate = prop($$props, "startDate", 8, null);
  let endDate = prop($$props, "endDate", 8, null);
  let weekStart = prop($$props, "weekStart", 8, 1);
  let initialView = prop($$props, "initialView", 8, MODE_MONTH);
  let i18n = prop($$props, "i18n", 8);
  let enableTimeToggle = prop($$props, "enableTimeToggle", 8, false);
  let isRange = prop($$props, "isRange", 8, false);
  let hoverDate = prop($$props, "hoverDate", 12, null);
  let additionalDisableFn = prop($$props, "additionalDisableFn", 8);
  function handleGridNav(key, shiftKey) {
    if (strict_equals(get(currentView), MODE_MONTH, false)) {
      set(currentView, MODE_MONTH);
      set(viewDelta, 1);
      set(activeDate, new Date(get(internalDate) || /* @__PURE__ */ new Date()));
      return;
    }
    if (!get(internalDate)) {
      onClick(/* @__PURE__ */ new Date(), { keyboard: true });
      return;
    }
    let dateToSelect = new Date(get(internalDate));
    switch (key) {
      case "PageDown":
        shiftKey = true;
      case "ArrowDown":
        shiftKey ? dateToSelect.setMonth(get(internalDate).getMonth() + 1) : dateToSelect.setDate(get(internalDate).getDate() + 7);
        if (shiftKey && strict_equals(dateToSelect.getMonth(), get(internalDate).getMonth())) {
          dateToSelect.setDate(0);
        }
        onClick(dateToSelect, { keyboard: true });
        break;
      case "PageUp":
        shiftKey = true;
      case "ArrowUp":
        shiftKey ? dateToSelect.setMonth(get(internalDate).getMonth() - 1) : dateToSelect.setDate(get(internalDate).getDate() - 7);
        if (shiftKey && strict_equals(dateToSelect.getMonth(), get(internalDate).getMonth())) {
          dateToSelect.setDate(0);
        }
        onClick(dateToSelect, { keyboard: true });
        break;
      case "ArrowLeft":
        shiftKey ? dateToSelect.setFullYear(get(internalDate).getFullYear() - 1) : dateToSelect.setDate(get(internalDate).getDate() - 1);
        onClick(dateToSelect, { keyboard: true });
        break;
      case "ArrowRight":
        shiftKey ? dateToSelect.setFullYear(get(internalDate).getFullYear() + 1) : dateToSelect.setDate(get(internalDate).getDate() + 1);
        onClick(dateToSelect, { keyboard: true });
        break;
    }
  }
  let internalDate = mutable_state(dates()[wid()] || null);
  let activeDate = mutable_state(strict_equals(wid(), 1) ? (() => {
    if (strict_equals(dates().length, 2) && dates()[1] && (equals(dates()[0].getMonth(), dates()[1].getMonth(), false) || equals(dates()[0].getFullYear(), dates()[1].getFullYear(), false))) return dates()[1];
    const d = new Date(dates()[0] || /* @__PURE__ */ new Date());
    d.setMonth(d.getMonth() + 1);
    return d;
  })() : new Date(((_a = dates()[0]) == null ? void 0 : _a.valueOf()) || /* @__PURE__ */ new Date()));
  const dispatch = createEventDispatcher();
  let currentView = mutable_state(initialView());
  let viewDelta = mutable_state(-2);
  let viewChanged = mutable_state(false);
  let duration = 400;
  const TRANSFORM_CONST = 222;
  const TRANSFORM_DECADE_UNEVEN = 148;
  let transform = mutable_state(TRANSFORM_CONST);
  let onMonthTransitionTrigger = mutable_state(null);
  function isBetween(num) {
    return get(dataset).prevTo <= num && num < get(dataset).nextFrom;
  }
  function isDisabledDate(date) {
    var _a2, _b;
    switch (get(currentView)) {
      case MODE_MONTH:
        if (get(computedStartDate) && get(computedStartDate) > date) return true;
        if (endDate() && endDate() <= date) return true;
        if (additionalDisableFn() && additionalDisableFn()(date)) return true;
        break;
      case MODE_YEAR:
        const dateYear = date.getFullYear();
        const startYear = (_a2 = get(computedStartDate)) == null ? void 0 : _a2.getFullYear();
        const endYear = (_b = endDate()) == null ? void 0 : _b.getFullYear();
        if (get(computedStartDate)) {
          if (strict_equals(startYear, dateYear) && get(computedStartDate).getMonth() > date.getMonth() || startYear > dateYear) return true;
        }
        if (endDate()) {
          if (strict_equals(endYear, dateYear) && endDate().getMonth() < date.getMonth() || endYear < dateYear) return true;
        }
        break;
      case MODE_DECADE:
        if (get(computedStartDate) && get(computedStartDate).getFullYear() > date.getFullYear()) return true;
        if (endDate() && endDate().getFullYear() < date.getFullYear()) return true;
        break;
    }
    return false;
  }
  function disableButtonNav(date, direction, mode) {
    const compareToEndDate = strict_equals(direction, 1);
    const dateToCompare = compareToEndDate ? endDate() : get(computedStartDate);
    if (dateToCompare) {
      if (strict_equals(mode, MODE_DECADE)) return compareToEndDate ? date.getFullYear() + direction * 10 > dateToCompare.getFullYear() : date.getFullYear() + direction * 10 < dateToCompare.getFullYear();
      if (strict_equals(mode, MODE_YEAR)) {
        return compareToEndDate ? date.getFullYear() + direction > dateToCompare.getFullYear() : date.getFullYear() + direction < dateToCompare.getFullYear();
      }
      return compareToEndDate ? date.getFullYear() * 100 + date.getMonth() + direction > dateToCompare.getFullYear() * 100 + dateToCompare.getMonth() : date.getFullYear() * 100 + date.getMonth() + direction < dateToCompare.getFullYear() * 100 + dateToCompare.getMonth();
    }
    return false;
  }
  function onChangeMonth(val) {
    const multiplier = strict_equals(get(currentView), MODE_DECADE) ? 120 : strict_equals(get(currentView), MODE_YEAR) ? 12 : 1;
    const newActiveDate = new Date(get(activeDate));
    newActiveDate.getDate() > 28 ? newActiveDate.setDate(newActiveDate.getDate() - 3) : newActiveDate;
    newActiveDate.setMonth(get(activeDate).getMonth() + val * multiplier);
    set(activeDate, newActiveDate);
    set(onMonthTransitionTrigger, null);
    set(transform, strict_equals(get(currentView), MODE_DECADE) ? get(activeDate).getFullYear() % 20 >= 10 ? TRANSFORM_CONST : TRANSFORM_DECADE_UNEVEN : TRANSFORM_CONST);
  }
  function onTransformChangeMonth(val) {
    if (strict_equals(get(currentView), MODE_MONTH)) {
      return onChangeMonth(val);
    }
    set(onMonthTransitionTrigger, () => {
      onChangeMonth(val);
    });
    if (strict_equals(get(currentView), MODE_DECADE)) {
      set(transform, strict_equals(get(transform), TRANSFORM_DECADE_UNEVEN) ? strict_equals(val, -1) ? get(transform) - TRANSFORM_CONST : TRANSFORM_CONST + TRANSFORM_DECADE_UNEVEN : strict_equals(val, -1) ? get(transform) - TRANSFORM_CONST : get(transform) + TRANSFORM_DECADE_UNEVEN);
      return;
    }
    set(transform, strict_equals(val, -1) ? get(transform) - TRANSFORM_CONST : get(transform) + TRANSFORM_CONST);
  }
  function onSwitchView() {
    set(viewDelta, -1);
    set(viewChanged, true);
    get(currentView) && update(currentView, -1);
    if (strict_equals(get(currentView), MODE_DECADE)) {
      const isLongerMove = strict_equals(Math.floor(get(activeDate).getFullYear() / 10) * 10 % 20, 0);
      set(transform, isLongerMove ? TRANSFORM_DECADE_UNEVEN : TRANSFORM_CONST);
    }
  }
  function onClick(value, { keyboard } = {}) {
    set(viewDelta, 1);
    set(viewChanged, true);
    switch (get(currentView)) {
      case 0:
        get(activeDate).setFullYear(value);
        set(activeDate, get(activeDate));
        break;
      case 1:
        get(activeDate).setMonth(i18n().monthsShort.indexOf(value));
        set(activeDate, get(activeDate));
        break;
      case 2:
        if (isDisabledDate(value)) return;
        if (additionalDisableFn() && additionalDisableFn()(value)) return;
        const newInternalDate = new Date(value.getFullYear(), value.getMonth(), value.getDate());
        if (get(internalDate)) {
          newInternalDate.setMinutes(get(internalDate).getMinutes());
          newInternalDate.setHours(get(internalDate).getHours());
        }
        set(internalDate, newInternalDate);
        if (keyboard) {
          if (strict_equals(get(activeDate).getFullYear(), newInternalDate.getFullYear(), false) || strict_equals(get(activeDate).getFullYear(), newInternalDate.getFullYear()) && strict_equals(get(activeDate).getMonth(), newInternalDate.getMonth(), false)) {
            get(activeDate).setFullYear(newInternalDate.getFullYear());
            get(activeDate).getDate() > 28 && get(activeDate).setDate(28);
            get(activeDate).setMonth(newInternalDate.getMonth());
            set(activeDate, get(activeDate));
          }
        }
        dispatch("date", {
          value: get(internalDate),
          update: "date",
          isKeyboard: keyboard
        });
        break;
    }
    get(currentView) < MODE_MONTH && update(currentView);
    set(transform, TRANSFORM_CONST);
  }
  function onTransitionOut() {
    set(viewChanged, false);
  }
  function onTimeSwitch() {
    dispatch("switch", "time");
  }
  function showCaption(currentView2, activeDate2) {
    switch (currentView2) {
      case MODE_DECADE:
        const from = get(dataset).years[Math.floor(get(dataset).prevTo / 4)][get(dataset).prevTo % 4];
        const to = get(dataset).years[Math.floor(get(dataset).nextFrom / 4)][get(dataset).nextFrom % 4];
        return `${from} - ${to}`;
      case MODE_YEAR:
        return activeDate2.getFullYear();
      case MODE_MONTH:
        return i18n().months[activeDate2.getMonth()] + " " + activeDate2.getFullYear();
    }
  }
  function wrapHoverDateToggle(currDate = null) {
    return function(event2) {
      hoverDate((currDate == null ? void 0 : currDate.getTime()) || null);
      dispatch("internal_hoverUpdate", hoverDate());
    };
  }
  function isInRange(timestamp) {
    return strict_equals(get(times).length, 2) ? timestamp >= get(times)[0] && timestamp < get(times)[1] : false;
  }
  function isRangeHoverable(timestamp, hoverDate2) {
    return hoverDate2 && strict_equals(get(times).length, 1) && (timestamp <= hoverDate2 && get(times)[0] <= timestamp || timestamp >= hoverDate2 && get(times)[0] >= timestamp);
  }
  legacy_pre_effect(() => deep_read_state(startDate()), () => {
    set(computedStartDate, startDate() ? new Date(startDate().getFullYear(), startDate().getMonth(), startDate().getDate(), 0, 0, 0, 0) : null);
  });
  legacy_pre_effect(() => get(viewDelta), () => {
    set(start, get(viewDelta) < 1 ? 1.5 : 0.5);
  });
  legacy_pre_effect(() => get(viewDelta), () => {
    set(end, get(viewDelta) < 1 ? 1 : 1.5);
  });
  legacy_pre_effect(() => (get(viewDelta), fade, scale), () => {
    set(swapTransition, strict_equals(get(viewDelta), -2) ? fade : strict_equals(get(viewDelta), null, false) ? scale : () => ({}));
  });
  legacy_pre_effect(() => deep_read_state(dates()), () => {
    set(times, dates().map((date) => {
      date = new Date(date);
      date.setHours(0, 0);
      return date.getTime();
    }));
  });
  legacy_pre_effect(
    () => (compute, get(activeDate), deep_read_state(dates()), get(currentView), deep_read_state(i18n()), deep_read_state(weekStart())),
    () => {
      set(dataset, compute(get(activeDate), dates(), get(currentView), i18n(), weekStart()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(i18n()), deep_read_state(weekStart())),
    () => {
      set(dayLabels, i18n().daysMin.concat(...i18n().daysMin.slice(1)).slice(weekStart(), 7 + weekStart()));
    }
  );
  legacy_pre_effect(() => deep_read_state(dates()), () => {
    if (strict_equals(dates().length, 0)) set(internalDate, null);
  });
  legacy_pre_effect(
    () => (deep_read_state(i18n()), get(currentView), get(activeDate)),
    () => {
      set(tableCaption, i18n() && showCaption(get(currentView), get(activeDate)));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root();
  var div = first_child(fragment);
  var button = child(div);
  var text = child(button, true);
  reset(button);
  var node = sibling(button, 2);
  if_block(node, () => enableTimeToggle() && dates().length, ($$anchor2) => {
    var button_1 = root_1();
    template_effect(() => set_attribute(button_1, "title", i18n().timeView));
    event("click", button_1, onTimeSwitch);
    append($$anchor2, button_1);
  });
  var button_2 = sibling(node, 2);
  template_effect(() => button_2.disabled = disableButtonNav(get(activeDate), -1, get(currentView)));
  var button_3 = sibling(button_2, 2);
  template_effect(() => button_3.disabled = disableButtonNav(get(activeDate), 1, get(currentView)));
  next(2);
  reset(div);
  var div_1 = sibling(div, 2);
  var node_1 = child(div_1);
  if_block(node_1, () => strict_equals(get(currentView), MODE_DECADE), ($$anchor2) => {
    var table = root_2();
    var tbody = child(table);
    each(tbody, 5, () => get(dataset).years, index, ($$anchor3, row, i) => {
      var tr = root_3();
      each(tr, 5, () => get(row), index, ($$anchor4, year, j) => {
        var td = root_4();
        const idx = derived_safe_equal(() => i * 4 + j);
        get(idx);
        const class_directive = derived_safe_equal(() => get(dataset).selectionMark.includes(get(idx)));
        template_effect(() => toggle_class(td, "is-selected", get(class_directive)));
        var button_4 = child(td);
        template_effect(() => button_4.disabled = isDisabledDate(new Date(get(year), get(activeDate).getMonth(), get(activeDate).getDate())));
        const class_directive_1 = derived_safe_equal(() => !isBetween(get(idx)));
        var text_1 = child(button_4, true);
        reset(button_4);
        reset(td);
        template_effect(() => {
          toggle_class(button_4, "not-current", get(class_directive_1));
          set_text(text_1, get(year));
        });
        event("click", button_4, () => {
          onClick(get(year));
        });
        append($$anchor4, td);
      });
      reset(tr);
      append($$anchor3, tr);
    });
    reset(tbody);
    reset(table);
    template_effect(() => {
      set_attribute(tbody, "style", `transform: translateY(-${get(transform)}px); color: red`);
      toggle_class(tbody, "animate-transition", get(onMonthTransitionTrigger) ? true : false);
    });
    transition(1, tbody, () => get(swapTransition), () => ({
      duration,
      start: get(start),
      opacity: 1
    }));
    transition(2, tbody, () => get(swapTransition), () => ({ duration, end: get(end), start: 1 }));
    event("outroend", tbody, onTransitionOut);
    event("transitionend", tbody, () => get(onMonthTransitionTrigger) && get(onMonthTransitionTrigger)());
    append($$anchor2, table);
  });
  var node_2 = sibling(node_1, 2);
  if_block(node_2, () => strict_equals(get(currentView), MODE_YEAR), ($$anchor2) => {
    var table_1 = root_5();
    var tbody_1 = child(table_1);
    each(tbody_1, 5, () => get(dataset).months, index, ($$anchor3, row, i) => {
      var tr_1 = root_6();
      each(tr_1, 5, () => get(row), index, ($$anchor4, month, j) => {
        var td_1 = root_7();
        const idx = derived_safe_equal(() => i * 4 + j);
        get(idx);
        var button_5 = child(td_1);
        template_effect(() => button_5.disabled = isDisabledDate(new Date(get(activeDate).getFullYear(), i18n().monthsShort.indexOf(get(month)), get(activeDate).getDate())));
        const class_directive_2 = derived_safe_equal(() => !isBetween(get(idx)));
        var text_2 = child(button_5, true);
        reset(button_5);
        reset(td_1);
        template_effect(() => {
          toggle_class(td_1, "is-selected", strict_equals(get(idx), get(dataset).selectionMark[0]));
          toggle_class(button_5, "not-current", get(class_directive_2));
          set_text(text_2, get(month));
        });
        event("click", button_5, () => {
          onClick(get(month));
        });
        append($$anchor4, td_1);
      });
      reset(tr_1);
      append($$anchor3, tr_1);
    });
    reset(tbody_1);
    reset(table_1);
    template_effect(() => {
      set_attribute(tbody_1, "style", `transform: translateY(-${get(transform)}px)`);
      toggle_class(tbody_1, "animate-transition", get(onMonthTransitionTrigger) ? true : false);
    });
    transition(1, tbody_1, () => get(swapTransition), () => ({
      duration,
      start: get(start),
      opacity: 1
    }));
    transition(2, tbody_1, () => get(swapTransition), () => ({ duration, end: get(end), start: 1 }));
    event("outroend", tbody_1, onTransitionOut);
    event("transitionend", tbody_1, () => get(onMonthTransitionTrigger) && get(onMonthTransitionTrigger)());
    append($$anchor2, table_1);
  });
  var node_3 = sibling(node_2, 2);
  if_block(node_3, () => strict_equals(get(currentView), MODE_MONTH), ($$anchor2) => {
    var table_2 = root_8();
    var tbody_2 = child(table_2);
    var tr_2 = child(tbody_2);
    each(tr_2, 5, () => get(dayLabels), index, ($$anchor3, header) => {
      var th = root_9();
      var text_3 = child(th, true);
      reset(th);
      template_effect(() => set_text(text_3, get(header)));
      append($$anchor3, th);
    });
    reset(tr_2);
    var node_4 = sibling(tr_2);
    each(node_4, 1, () => get(dataset).days, index, ($$anchor3, row, i) => {
      var tr_3 = root_10();
      each(tr_3, 5, () => get(row), index, ($$anchor4, currDate, j) => {
        var td_2 = root_11();
        const idx = derived_safe_equal(() => i * 7 + j);
        get(idx);
        const dateTime = derived_safe_equal(() => get(currDate).getTime());
        get(dateTime);
        var event_handler = derived(() => wrapHoverDateToggle(get(currDate)));
        var event_handler_1 = derived(wrapHoverDateToggle);
        const class_directive_3 = derived_safe_equal(() => isInRange(get(dateTime)));
        template_effect(() => toggle_class(td_2, "in-range", get(class_directive_3)));
        const class_directive_4 = derived_safe_equal(() => get(times).includes(get(dateTime)));
        template_effect(() => toggle_class(td_2, "is-selected", get(class_directive_4)));
        const class_directive_5 = derived_safe_equal(() => isRange() && isRangeHoverable(get(dateTime), hoverDate()));
        template_effect(() => toggle_class(td_2, "in-range-hover", get(class_directive_5)));
        var button_6 = child(td_2);
        template_effect(() => button_6.disabled = (get(computedStartDate) || endDate() || additionalDisableFn()) && isDisabledDate(get(currDate)));
        const class_directive_6 = derived_safe_equal(() => !isBetween(i * 7 + j));
        var text_4 = child(button_6, true);
        template_effect(() => set_text(text_4, get(currDate).getDate()));
        reset(button_6);
        reset(td_2);
        template_effect(() => {
          toggle_class(td_2, "sdt-today", strict_equals(get(idx), get(dataset).todayMark));
          toggle_class(button_6, "not-current", get(class_directive_6));
        });
        event("click", button_6, () => {
          onClick(get(currDate));
        });
        event("mouseover", td_2, function(...$$args) {
          apply(() => get(event_handler), this, $$args, Calendar, [444, 24], true);
        });
        event("mouseout", td_2, function(...$$args) {
          apply(() => get(event_handler_1), this, $$args, Calendar, [445, 23], true, true);
        });
        append($$anchor4, td_2);
      });
      reset(tr_3);
      append($$anchor3, tr_3);
    });
    reset(tbody_2);
    reset(table_2);
    transition(1, tbody_2, () => get(swapTransition), () => ({ duration, start: 0.5, opacity: 1 }));
    transition(2, tbody_2, () => get(swapTransition), () => ({
      duration,
      start: Math.abs(get(viewDelta))
    }));
    event("outroend", tbody_2, onTransitionOut);
    append($$anchor2, table_2);
  });
  reset(div_1);
  template_effect(() => {
    set_text(text, get(tableCaption));
    toggle_class(div_1, "is-grid", get(viewChanged));
  });
  event("click", button, onSwitchView);
  event("click", button_2, () => onTransformChangeMonth(-1));
  event("click", button_3, () => onTransformChangeMonth(1));
  append($$anchor, fragment);
  bind_prop($$props, "handleGridNav", handleGridNav);
  return pop({
    get handleGridNav() {
      return handleGridNav;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Calendar = hmr(Calendar, () => Calendar[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-mEMfzfAXZadf");
    module.default[HMR].source = Calendar[HMR].source;
    set(Calendar[HMR].source, module.default[HMR].original);
  });
}
var Calendar_default = Calendar;
mark_module_end(Calendar);

// node_modules/svelty-picker/dist/components/Time.svelte
mark_module_start();
Time[FILENAME] = "node_modules/svelty-picker/dist/components/Time.svelte";
var root_12 = add_locations(template(`<button type="button" class="sdt-time-btn sdt-back-btn s-9Nv-WYYoEwBr"><svg class="sdt-svg s-9Nv-WYYoEwBr" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path fill-rule="evenodd" d="M6.75 0a.75.75 0 01.75.75V3h9V.75a.75.75 0 011.5 0V3h2.75c.966 0 1.75.784 1.75 1.75v16a1.75 1.75 0 01-1.75 1.75H3.25a1.75 1.75 0 01-1.75-1.75v-16C1.5 3.784 2.284 3 3.25 3H6V.75A.75.75 0 016.75 0zm-3.5 4.5a.25.25 0 00-.25.25V8h18V4.75a.25.25 0 00-.25-.25H3.25zM21 9.5H3v11.25c0 .138.112.25.25.25h17.5a.25.25 0 00.25-.25V9.5z" class="s-9Nv-WYYoEwBr"></path></svg></button>`), Time[FILENAME], [
  [
    346,
    4,
    [[347, 6, [[347, 105]]]]
  ]
]);
var root_22 = add_locations(template(`<button type="button" class="sdt-time-btn sdt-time-figure s-9Nv-WYYoEwBr"> </button> <span class="s-9Nv-WYYoEwBr">:</span> <button type="button" class="sdt-time-btn sdt-time-figure s-9Nv-WYYoEwBr"> </button>`, 1), Time[FILENAME], [[351, 4], [355, 4], [356, 4]]);
var root_42 = add_locations(template(`<span class="sdt-time-figure s-9Nv-WYYoEwBr"> </span>`), Time[FILENAME], [[363, 6]]);
var root_52 = add_locations(template(`<span class="s-9Nv-WYYoEwBr">:</span> <span class="sdt-time-figure s-9Nv-WYYoEwBr">00</span>`, 1), Time[FILENAME], [[365, 6], [366, 6]]);
var root_32 = add_locations(template(`<span class="sdt-time-figure s-9Nv-WYYoEwBr"> </span> <!>`, 1), Time[FILENAME], [[361, 4]]);
var root_62 = add_locations(template(`<div class="sdt-meridian s-9Nv-WYYoEwBr"><button type="button" class="sdt-time-btn sdt-time-figure is-active s-9Nv-WYYoEwBr"> </button></div>`), Time[FILENAME], [[370, 4, [[371, 6]]]]);
var root_72 = add_locations(template(`<button type="button" class="sdt-tick s-9Nv-WYYoEwBr"> </button>`), Time[FILENAME], [[384, 6]]);
var root_82 = add_locations(template(`<button type="button" class="sdt-tick s-9Nv-WYYoEwBr"> </button>`), Time[FILENAME], [[391, 6]]);
var root2 = add_locations(template(`<div class="sdt-timer s-9Nv-WYYoEwBr"><div class="sdt-time-head s-9Nv-WYYoEwBr"><!> <!> <!></div>  <div class="sdt-clock s-9Nv-WYYoEwBr"><div class="sdt-middle-dot s-9Nv-WYYoEwBr"></div> <div class="sdt-hand-pointer s-9Nv-WYYoEwBr"><div class="sdt-hand-circle s-9Nv-WYYoEwBr"></div></div> <!> <!></div></div>`), Time[FILENAME], [
  [
    343,
    0,
    [
      [344, 2],
      [
        378,
        2,
        [
          [379, 4],
          [380, 4, [[381, 6]]]
        ]
      ]
    ]
  ]
]);
var $$css2 = {
  hash: "s-9Nv-WYYoEwBr",
  code: "\n.sdt-timer.s-9Nv-WYYoEwBr {\n  position: relative;\n  /* width: 272px; */\n  --sdt-clock-size: 220px;\n}\n.sdt-time-head.s-9Nv-WYYoEwBr {\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin-bottom: 4px;\n  color: var(--sdt-header-color, initial);\n}\n.sdt-time-figure.s-9Nv-WYYoEwBr {\n  font-size: 1.5em;\n  font-weight: bold;\n  padding: 0 0.375em;\n}\n.sdt-time-figure.s-9Nv-WYYoEwBr + .sdt-time-figure:where(.s-9Nv-WYYoEwBr) {\n  margin-left: -12px;\n}\n.sdt-clock.s-9Nv-WYYoEwBr {\n  margin: auto;\n  position: relative;\n  width: var(--sdt-clock-size);\n  height: var(--sdt-clock-size);\n  background-color: var(--sdt-clock-bg, #eeeded);\n  border-radius: 50%;\n  transition: background-color 0.3s;\n  overflow: hidden;\n}\n.sdt-time-btn.s-9Nv-WYYoEwBr {\n  border: 0;\n  background: transparent;\n  text-align: center;\n  border-radius: 4px;\n  cursor: pointer;\n  height: 38px;\n  padding: 0 0.375em;\n  color: var(--sdt-header-color, initial);\n}\n.sdt-time-btn.s-9Nv-WYYoEwBr > svg:where(.s-9Nv-WYYoEwBr) {\n  stroke: initial !important;\n}\n.sdt-svg.s-9Nv-WYYoEwBr {\n  fill: var(--sdt-header-color, initial);\n}\n.sdt-time-btn.s-9Nv-WYYoEwBr:not(.is-active:where(.s-9Nv-WYYoEwBr)) {\n  opacity: 0.5;\n}\n.sdt-time-btn.s-9Nv-WYYoEwBr:hover {\n  background-color: var(--sdt-header-btn-bg-hover, #dfdfdf);\n}\n.sdt-back-btn.s-9Nv-WYYoEwBr {\n  position: absolute;\n  top: 0;\n  left: 0;\n  padding: 0.3em;\n  opacity: 1 !important;\n}\n.sdt-meridian.s-9Nv-WYYoEwBr {\n  position: absolute;\n  top: 0;\n  right: 0;\n  display: flex;\n}\n.sdt-meridian.s-9Nv-WYYoEwBr .sdt-time-btn:where(.s-9Nv-WYYoEwBr) {\n  width: 56px;\n  font-weight: bold;\n}\n.sdt-middle-dot.s-9Nv-WYYoEwBr {\n  left: 50%;\n  top: 50%;\n  width: 6px;\n  height: 6px;\n  position: absolute;\n  transform: translate(-50%, -50%);\n  background-color: var(--sdt-clock-selected-bg, var(--sdt-bg-selected, #286090));\n  border-radius: 50%;\n}\n.sdt-hand-pointer.s-9Nv-WYYoEwBr {\n  width: 2px;\n  height: calc(40% - 3px);\n  bottom: 50%;\n  left: calc(50% - 1px);\n  position: absolute;\n  background-color: var(--sdt-clock-selected-bg, var(--sdt-bg-selected, #286090));\n  transform-origin: center bottom 0;\n  transition: transform 0.3s ease, height 0.15s ease;\n}\n.sdt-hand-circle.s-9Nv-WYYoEwBr {\n  left: -15px;\n  top: -21px;\n  position: relative;\n  width: 4px;\n  height: 4px;\n  background-color: transparent;\n  border: 14px solid var(--sdt-clock-selected-bg, var(--sdt-bg-selected, #286090));\n  border-radius: 50%;\n  box-sizing: content-box;\n}\n\n.sdt-tick.s-9Nv-WYYoEwBr {\n  position: absolute;\n  width: 30px;\n  height: 30px;\n  border-width: 0;\n  transform: translate(-50%, -50%);\n  text-align: center;\n  border-radius: 50%;\n  line-height: 20px;\n  cursor: pointer;\n  background-color: var(--sdt-clock-time-bg);\n  transition: all 0.3s;\n  color: var(--sdt-clock-color, inherit);\n}\n.sdt-tick.s-9Nv-WYYoEwBr:hover {\n	color: var(--sdt-clock-color-hover);\n	background-color: var(--sdt-clock-time-bg-hover);\n}\n.sdt-tick[disabled].s-9Nv-WYYoEwBr {\n  cursor: not-allowed;\n  color: var(--sdt-clock-disabled, #b22222);\n  background-color: var(--sdt-clock-disabled-bg, var(--sdt-clock-bg,#eeeded));\n}\n.sdt-tick.outer-tick.s-9Nv-WYYoEwBr {\n  opacity: 0;\n}\n.sdt-tick.is-selected.s-9Nv-WYYoEwBr {\n  animation: s-9Nv-WYYoEwBr-tick-selection 0s 0.175s ease-out forwards;\n}\n@keyframes s-9Nv-WYYoEwBr-tick-selection {\n  0% {\n    color: initial;\n    background-color: transparent;\n  }\n  100% {\n    background-color: var(--sdt-clock-selected-bg, var(--sdt-bg-selected, #286090));\n    color: var(--sdt-color-selected, var(--sdt-bg-main, #fff));\n  }\n}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGltZS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiVGltZS5zdmVsdGUiXX0= */"
};
function Time($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Time);
  append_styles($$anchor, $$css2);
  const selectedHour = mutable_state();
  const isPM = mutable_state();
  const selectedMinutes = mutable_state();
  const multiplier = mutable_state();
  const sameDateRestriction = mutable_state();
  const pos = mutable_state();
  const innerHours = mutable_state();
  let wid = prop($$props, "wid", 8);
  let date = prop($$props, "date", 12, null);
  let startDate = prop($$props, "startDate", 8, null);
  let endDate = prop($$props, "endDate", 8, null);
  let hourOnly = prop($$props, "hourOnly", 8, false);
  let minuteIncrement = prop($$props, "minuteIncrement", 8, 1);
  let showMeridian = prop($$props, "showMeridian", 8, false);
  let hasDateComponent = prop($$props, "hasDateComponent", 8, false);
  let i18n = prop($$props, "i18n", 8);
  function showMinuteView() {
    set(isMinuteView, true);
  }
  function makeTick(val) {
    if (get(isMinuteView)) {
      val = val * 5 + get(selectedMinutes);
      if (strict_equals(val % 5, 0, false)) {
        val = val < get(selectedMinutes) ? val + (5 - val % 5) : val - val % 5;
      }
    } else {
      val = get(selectedHour) + val;
    }
    enableViewToggle = false;
    onClick({
      type: "keyboard",
      target: { tagName: "BUTTON", dataset: { value: val } }
    });
    enableViewToggle = true;
  }
  let clockEl = mutable_state();
  let isMinuteView = mutable_state(false);
  let handleMoveMove = mutable_state(false);
  let enableViewToggle = true;
  let innerDate = mutable_state(date() || /* @__PURE__ */ new Date());
  if (!date()) {
    date(get(innerDate));
    date().setHours(0, 0, 0, 0);
  }
  const dispatch = createEventDispatcher();
  let handCss = mutable_state("");
  function positions(size2, offset2, valueForZero, minuteView, hourAdded) {
    const r = size2 / 2;
    offset2 = offset2 || r;
    const coeff = [
      0,
      1 - 0.5,
      1 - 0.134,
      1,
      1 - 0.134,
      1 - 0.5
    ];
    const xCoeff = coeff.concat(coeff);
    const yCoeff = coeff.slice(3).concat(coeff).concat(coeff.slice(0, 3));
    const pos2 = [];
    for (let i = 0; i < 12; (i += 1) - 1) {
      pos2.push({
        x: Math.abs(xCoeff[i] * r + (i <= 6 ? 1 : -1) * offset2),
        y: Math.abs(yCoeff[i] * r + (i >= 9 || i < 3 ? -1 : 1) * offset2),
        val: minuteView ? i * 5 || valueForZero : i ? i + hourAdded : valueForZero
      });
    }
    return pos2;
  }
  function view(value, asMeridian) {
    if (asMeridian) {
      if (get(isPM) && strict_equals(value, 12)) return 12;
      return value < 10 || value % 12 < 10 ? `0${value % 12}` : value % 12;
    }
    return value < 10 ? `0${value}` : value;
  }
  function isSelected(selected, val, i) {
    if (get(isMinuteView)) {
      return strict_equals(val, selected) || strict_equals(i, 0) && strict_equals(i, selected);
    } else {
      if (showMeridian()) {
        if (get(isPM) && equals(val, 12) && strict_equals(selected, 12)) return true;
        if (!get(isPM) && equals(val, 12) && strict_equals(selected, 0)) return true;
        return strict_equals(val, selected ? selected % 12 : 12);
      } else if (+val > 12) {
        return strict_equals(i ? get(multiplier) * i + 12 : 0, selected);
      } else {
        return strict_equals(val, "00") || strict_equals(val, "12") ? strict_equals(selected, 12) && equals(parseInt(val), 12) || strict_equals(val, "00") && strict_equals(selected, 0) : strict_equals(val, selected);
      }
    }
  }
  function isDisabled(val, isManualMinuteCheck = false) {
    if (strict_equals(typeof val, "string")) val = parseInt(val);
    if (startDate() && endDate() && get(sameDateRestriction)) {
      if (get(isMinuteView) || isManualMinuteCheck) {
        return strict_equals(startDate().getHours(), get(innerDate).getHours()) && startDate().getMinutes() > val || strict_equals(endDate().getHours(), get(innerDate).getHours()) && endDate().getMinutes() < val;
      }
      return startDate().getHours() > val || endDate().getHours() < val;
    }
    if (startDate() && strict_equals(startDate().getDate(), get(innerDate).getDate()) && strict_equals(startDate().getMonth(), get(innerDate).getMonth()) && strict_equals(startDate().getFullYear(), get(innerDate).getFullYear())) {
      if (get(isMinuteView) || isManualMinuteCheck) {
        return strict_equals(startDate().getHours(), get(innerDate).getHours()) && startDate().getMinutes() > val;
      }
      return startDate().getHours() > val;
    }
    if (endDate() && strict_equals(endDate().getDate(), get(innerDate).getDate()) && strict_equals(endDate().getMonth(), get(innerDate).getMonth()) && strict_equals(endDate().getFullYear(), get(innerDate).getFullYear())) {
      if (get(isMinuteView) || isManualMinuteCheck) {
        return strict_equals(endDate().getHours(), get(innerDate).getHours()) && endDate().getMinutes() < val;
      }
      return endDate().getHours() < val;
    }
    return false;
  }
  function onClick(e) {
    if (!e.target) return;
    let a = 0;
    let b = 0;
    if (strict_equals(e.target.tagName, "BUTTON")) {
      let val = parseInt(e.target.dataset.value);
      const setter = !get(isMinuteView) ? "setHours" : "setMinutes";
      if (!get(isMinuteView) && get(isPM)) {
        val += 12;
      }
      if (get(isMinuteView) && strict_equals(minuteIncrement(), 1, false)) {
        if (e.isKeyboard) {
          val = val > get(selectedMinutes) ? get(selectedMinutes) + minuteIncrement() : get(selectedMinutes) - minuteIncrement();
        } else if (strict_equals(val % minuteIncrement(), 0, false)) {
          const diff = val % minuteIncrement();
          const prev = val - diff;
          const next2 = prev + minuteIncrement();
          val = next2 - val < val - prev ? next2 : prev;
        }
      }
      get(innerDate)[setter](val);
    } else if (get(isMinuteView)) {
      const rect = get(clockEl).getBoundingClientRect();
      const clientX = e.clientX - rect.left;
      const clientY = e.clientY - rect.top;
      const cntX = 110, cntY = 110;
      let quadrant = null;
      if (clientX > cntX) {
        quadrant = clientY > cntY ? 2 : 1;
      } else {
        quadrant = clientY > cntY ? 3 : 4;
      }
      switch (quadrant) {
        case 1:
          a = clientX - cntX;
          b = cntY - clientY;
          break;
        case 2:
          a = clientX - cntX;
          b = clientY - cntY;
          break;
        case 3:
          a = cntX - clientX;
          b = clientY - cntY;
          break;
        case 4:
          a = cntX - clientX;
          b = cntY - clientY;
          break;
      }
      const c = Math.sqrt(a * a + b * b);
      const beta = 90 - Math.asin(a / c) * (180 / Math.PI);
      let degree = 0;
      switch (quadrant) {
        case 1:
          degree = 90 - beta;
          break;
        case 2:
          degree = beta + 90;
          break;
        case 3:
          degree = 270 - beta;
          break;
        case 4:
          degree = beta + 270;
          break;
      }
      degree = Math.round(degree / 6 / minuteIncrement()) * minuteIncrement();
      if (degree >= 60) {
        degree = 0;
      }
      get(innerDate).setMinutes(degree);
    }
    set(innerDate, get(innerDate));
    if (!get(handleMoveMove)) {
      dispatch(get(isMinuteView) ? "minute" : "hour", {
        value: get(innerDate),
        isKeyboard: strict_equals(e.type, "keyboard"),
        dateIndex: wid()
      });
      if (strict_equals(e.type, "keyboard", false) && !get(isMinuteView) && !hourOnly()) {
        set(isMinuteView, true);
      }
    }
  }
  function onSwitchMeridian(e) {
    const val = parseInt(e.target.dataset.value);
    get(innerDate).setHours(val);
    set(innerDate, get(innerDate));
    dispatch(get(isMinuteView) ? "minute" : "hour", {
      value: get(innerDate),
      // isKeyboard: e.type === 'keyboard'
      isKeyboard: true
    });
  }
  function onToggleMove(e) {
    set(handleMoveMove, strict_equals(e.type, "mousedown"));
  }
  function onModeSwitch() {
    dispatch("switch", "date");
  }
  legacy_pre_effect(
    () => (deep_read_state(date()), get(innerDate)),
    () => {
      if (strict_equals(date(), get(innerDate), false) && date()) {
        set(innerDate, date());
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(startDate()), get(innerDate), deep_read_state(endDate()), tick),
    () => {
      let forceTimeUpdate = false;
      if (startDate() && strict_equals(startDate().toDateString(), get(innerDate).toDateString())) {
        if (isDisabled(get(innerDate).getHours())) {
          get(innerDate).setHours(startDate().getHours());
          forceTimeUpdate = true;
        }
        if (isDisabled(get(innerDate).getMinutes(), true)) {
          get(innerDate).setMinutes(startDate().getMinutes());
          forceTimeUpdate = true;
        }
      }
      if (endDate() && strict_equals(endDate().toDateString(), get(innerDate).toDateString())) {
        if (isDisabled(get(innerDate).getHours())) {
          get(innerDate).setHours(endDate().getHours());
          forceTimeUpdate = true;
        }
        if (isDisabled(get(innerDate).getMinutes(), true)) {
          get(innerDate).setMinutes(endDate().getMinutes());
          forceTimeUpdate = true;
        }
      }
      forceTimeUpdate && tick().then(() => dispatch("time", get(innerDate)));
    }
  );
  legacy_pre_effect(() => get(innerDate), () => {
    set(selectedHour, get(innerDate) ? get(innerDate).getHours() : 0);
  });
  legacy_pre_effect(
    () => (deep_read_state(showMeridian()), get(selectedHour)),
    () => {
      set(isPM, showMeridian() ? get(selectedHour) >= 12 : false);
    }
  );
  legacy_pre_effect(() => get(innerDate), () => {
    set(selectedMinutes, get(innerDate) ? get(innerDate).getMinutes() : 0);
  });
  legacy_pre_effect(
    () => (get(isMinuteView), get(selectedMinutes), get(selectedHour), deep_read_state(showMeridian())),
    () => {
      let nextDegree = get(isMinuteView) ? get(selectedMinutes) * 6 : get(selectedHour) % 12 * 30;
      set(handCss, get(isMinuteView) || showMeridian() || get(selectedHour) < 12 ? `transform: rotateZ(${nextDegree}deg);` : `transform: rotateZ(${nextDegree}deg); height: calc(25% + 1px)`);
    }
  );
  legacy_pre_effect(() => get(isMinuteView), () => {
    set(multiplier, get(isMinuteView) ? 5 : 1);
  });
  legacy_pre_effect(
    () => (deep_read_state(startDate()), deep_read_state(endDate())),
    () => {
      set(sameDateRestriction, startDate() && endDate() && ["getFullYear", "getMonth", "getDate"].every((p) => strict_equals(endDate()[p](), startDate()[p]())));
    }
  );
  legacy_pre_effect(() => get(isMinuteView), () => {
    set(pos, positions(get(isMinuteView) ? 220 : 180, 110, "00", false, 0));
  });
  legacy_pre_effect(() => get(isMinuteView), () => {
    set(innerHours, positions(get(isMinuteView) ? 180 : 120, 110, get(isMinuteView) ? "00" : "12", get(isMinuteView), 12));
  });
  legacy_pre_effect(() => get(isMinuteView), () => {
    dispatch("time-switch", get(isMinuteView));
  });
  legacy_pre_effect_reset();
  init();
  var div = root2();
  var div_1 = child(div);
  var node = child(div_1);
  if_block(node, hasDateComponent, ($$anchor2) => {
    var button = root_12();
    template_effect(() => set_attribute(button, "title", i18n().backToDate));
    event("click", button, onModeSwitch);
    append($$anchor2, button);
  });
  var node_1 = sibling(node, 2);
  if_block(
    node_1,
    () => !hourOnly(),
    ($$anchor2) => {
      var fragment = root_22();
      var button_1 = first_child(fragment);
      var text = child(button_1, true);
      template_effect(() => set_text(text, view(get(selectedHour), showMeridian())));
      reset(button_1);
      var button_2 = sibling(button_1, 4);
      var text_1 = child(button_2, true);
      template_effect(() => set_text(text_1, view(get(selectedMinutes), false)));
      reset(button_2);
      template_effect(() => {
        toggle_class(button_1, "is-active", !get(isMinuteView));
        toggle_class(button_2, "is-active", get(isMinuteView));
      });
      event("click", button_1, () => set(isMinuteView, false));
      event("click", button_2, () => set(isMinuteView, true));
      append($$anchor2, fragment);
    },
    ($$anchor2) => {
      var fragment_1 = root_32();
      var span = first_child(fragment_1);
      var text_2 = child(span, true);
      template_effect(() => set_text(text_2, view(get(selectedHour), showMeridian())));
      reset(span);
      var node_2 = sibling(span, 2);
      if_block(
        node_2,
        showMeridian,
        ($$anchor3) => {
          var span_1 = root_42();
          var text_3 = child(span_1, true);
          template_effect(() => set_text(text_3, (get(isPM) ? i18n().meridiem[1] : i18n().meridiem[0]).toUpperCase()));
          reset(span_1);
          append($$anchor3, span_1);
        },
        ($$anchor3) => {
          var fragment_2 = root_52();
          next(2);
          append($$anchor3, fragment_2);
        }
      );
      append($$anchor2, fragment_1);
    }
  );
  var node_3 = sibling(node_1, 2);
  if_block(node_3, showMeridian, ($$anchor2) => {
    var div_2 = root_62();
    var button_3 = child(div_2);
    var text_4 = child(button_3, true);
    reset(button_3);
    reset(div_2);
    template_effect(() => {
      set_attribute(button_3, "data-value", get(isPM) ? get(selectedHour) % 12 : get(selectedHour) + 12);
      set_text(text_4, get(isPM) ? i18n().meridiem[1] : i18n().meridiem[0]);
    });
    event("click", button_3, onSwitchMeridian);
    append($$anchor2, div_2);
  });
  reset(div_1);
  var div_3 = sibling(div_1, 2);
  var div_4 = sibling(child(div_3), 2);
  var node_4 = sibling(div_4, 2);
  validate_each_keys(() => get(pos), (p) => p.val);
  each(node_4, 3, () => get(pos), (p) => p.val, ($$anchor2, p, i) => {
    var button_4 = root_72();
    template_effect(() => button_4.disabled = (startDate() || endDate()) && get(innerDate) && isDisabled(get(p).val, false));
    const class_directive = derived_safe_equal(() => isSelected(get(selectedHour), get(p).val, get(i)));
    var text_5 = child(button_4, true);
    reset(button_4);
    template_effect(() => {
      set_attribute(button_4, "style", `left:${get(p).x}px; top:${get(p).y}px;`);
      set_attribute(button_4, "data-value", get(p).val);
      toggle_class(button_4, "outer-tick", get(isMinuteView));
      toggle_class(button_4, "is-selected", get(class_directive));
      set_text(text_5, get(p).val);
    });
    transition(3, button_4, () => fade, () => ({ duration: 200 }));
    append($$anchor2, button_4);
  });
  var node_5 = sibling(node_4, 2);
  each(node_5, 1, () => get(innerHours), index, ($$anchor2, p, i) => {
    var button_5 = root_82();
    template_effect(() => button_5.disabled = (startDate() || endDate()) && get(innerDate) && isDisabled(get(p).val, false));
    const class_directive_1 = derived_safe_equal(() => isSelected(get(isMinuteView) ? get(selectedMinutes) : get(selectedHour), get(p).val, i));
    var text_6 = child(button_5, true);
    reset(button_5);
    template_effect(() => {
      set_attribute(button_5, "style", `left:${get(p).x}px; top:${get(p).y}px;`);
      set_attribute(button_5, "data-value", get(p).val);
      toggle_class(button_5, "outer-tick", showMeridian() && !get(isMinuteView));
      toggle_class(button_5, "is-selected", get(class_directive_1));
      set_text(text_6, get(p).val);
    });
    transition(3, button_5, () => fade, () => ({ duration: 200 }));
    append($$anchor2, button_5);
  });
  reset(div_3);
  bind_this(div_3, ($$value) => set(clockEl, $$value), () => get(clockEl));
  reset(div);
  template_effect(() => {
    toggle_class(div_3, "is-minute-view", get(isMinuteView));
    set_attribute(div_4, "style", get(handCss));
  });
  event("click", div_3, preventDefault(onClick));
  event("mousedown", div_3, onToggleMove);
  event("mousemove", div_3, (e) => {
    get(handleMoveMove) && onClick(e);
  });
  event("mouseup", div_3, onToggleMove);
  transition(1, div, () => fade, () => ({ duration: 200 }));
  append($$anchor, div);
  bind_prop($$props, "showMinuteView", showMinuteView);
  bind_prop($$props, "makeTick", makeTick);
  return pop({
    get showMinuteView() {
      return showMinuteView;
    },
    get makeTick() {
      return makeTick;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Time = hmr(Time, () => Time[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-9Nv-WYYoEwBr");
    module.default[HMR].source = Time[HMR].source;
    set(Time[HMR].source, module.default[HMR].original);
  });
}
var Time_default = Time;
mark_module_end(Time);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale2.x;
  let y = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x = left * scale2.x;
  const y = top * scale2.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root4 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root4.clientWidth - (left + width));
    const insetBottom = floor(root4.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root4.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var shift2 = shift;
var flip2 = flip;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/svelty-picker/dist/utils/actions.js
function usePosition(node) {
  if ((node == null ? void 0 : node.previousElementSibling) === null) return;
  const prevElement = node == null ? void 0 : node.previousElementSibling;
  const removeFloating = autoUpdate(
    prevElement,
    node,
    () => computePosition2(prevElement, node, {
      placement: "bottom-start",
      middleware: [
        shift2({
          padding: 5
        }),
        flip2()
      ]
    }).then(({ x, y }) => {
      Object.assign(node.style, {
        left: `${x}px`,
        top: `${y}px`
      });
    })
  );
  return {
    destroy() {
      removeFloating();
    }
  };
}

// node_modules/svelty-picker/dist/utils/state.js
function initProps(value, initialDate, format, i18n, formatType) {
  let valueArray = value ? Array.isArray(value) ? value : value.split(",") : [];
  valueArray = valueArray.map((value2) => value2.replace(/(:\d+):\d+/, "$1"));
  let prevValue = valueArray;
  let innerDates = !initialDate ? prevValue.map((val) => parseDate(val, format, i18n, formatType)) : Array.isArray(initialDate) ? initialDate : [initialDate];
  if (innerDates && initialDate) {
    valueArray = innerDates.map((innerDate) => formatDate(innerDate, format, i18n, formatType));
  }
  return {
    valueArray,
    prevValue,
    innerDates
  };
}
function computeResolvedMode(mode, format) {
  return mode === "auto" ? format.match(/g|hh?|ii?/i) && format.match(/y|m|d/i) ? "datetime" : format.match(/g|hh?|ii?/i) ? "time" : "date" : mode;
}

// node_modules/svelty-picker/dist/components/SveltyPicker.svelte
mark_module_start();
SveltyPicker[FILENAME] = "node_modules/svelty-picker/dist/components/SveltyPicker.svelte";
var config = settings_default;
var root_33 = add_locations(template(`<input type="text" tabindex="0" autocomplete="off">`), SveltyPicker[FILENAME], [[553, 4]]);
var root_23 = add_locations(template(`<input type="hidden"> <!>`, 1), SveltyPicker[FILENAME], [[551, 4]]);
var root_53 = add_locations(template(`<div class="sdt-widget s-5BcMZRcOchej"><!></div>`), SveltyPicker[FILENAME], [[588, 4]]);
var root_102 = add_locations(template(`<span><button type="button"> </button> <button type="button"> </button></span>`), SveltyPicker[FILENAME], [
  [640, 6, [[641, 8], [642, 8]]]
]);
var root_122 = add_locations(template(`<button type="button"> </button>`), SveltyPicker[FILENAME], [[647, 48]]);
var root_13 = add_locations(template(`<button type="button"> </button>`), SveltyPicker[FILENAME], [[648, 22]]);
var root_112 = add_locations(template(`<span><!> <!></span>`), SveltyPicker[FILENAME], [[646, 6]]);
var root_92 = add_locations(template(`<div class="sdt-btn-row s-5BcMZRcOchej"><!> <!></div>`), SveltyPicker[FILENAME], [[638, 4]]);
var root_43 = add_locations(template(`<div><div class="sdt-widget-wrap s-5BcMZRcOchej"></div> <!></div>`), SveltyPicker[FILENAME], [[580, 2, [[586, 2]]]]);
var root3 = add_locations(template(`<span class="std-component-wrap s-5BcMZRcOchej"><!> <!></span>`), SveltyPicker[FILENAME], [[545, 0]]);
var $$css3 = {
  hash: "s-5BcMZRcOchej",
  code: "\n  .std-component-wrap.s-5BcMZRcOchej {\n    position: relative;\n    display: inline;\n  }\n  .std-calendar-wrap.s-5BcMZRcOchej {\n    width: 280px;\n    background-color: var(--sdt-bg-main, #fff);\n    box-shadow: var(--sdt-wrap-shadow, 0 1px 6px var(--sdt-shadow-color, #ccc));\n    border-radius: var(--sdt-radius, 4px);\n    padding: 0.5em;\n    color: var(--sdt-color, initial);\n  }\n  .std-calendar-wrap.is-range-wrap.s-5BcMZRcOchej {\n    width: 560px;\n  }\n  .sdt-widget-wrap.s-5BcMZRcOchej {\n    display: flex;\n    gap: 0.5rem;\n    justify-content: stretch;\n    position: relative;\n  }\n  .sdt-widget.s-5BcMZRcOchej {\n    flex: 1;\n    min-width: 264px;\n  }\n  .value-dirty.s-5BcMZRcOchej {\n    color: color-mix(in srgb, black 20%, white);\n  }\n  .std-calendar-wrap.is-popup.s-5BcMZRcOchej {\n    position: absolute;\n    box-shadow: 0 1px 6px var(--sdt-shadow-color, #ccc);\n    z-index: 100;\n  }\n  .sdt-btn-row.s-5BcMZRcOchej {\n    margin-top: 0.5rem;\n    display: flex;\n    gap: 0.5rem;\n    justify-content: space-between;\n    flex-flow: row-reverse;\n  }\n  .sdt-action-btn.s-5BcMZRcOchej {\n    padding: 0.25em 0.5em;\n    font-size: 0.875em;\n    border-radius: 0.2em;\n  }\n  .sdt-today-btn.s-5BcMZRcOchej {\n    background-color: var(--sdt-bg-selected, #286090);\n    color: var(--sdt-today-color, var(--sdt-bg-main, #fff));\n    padding: 0.25em 0.5em;\n    font-size: 0.875em;\n    border-radius: 0.2em;\n    border: 1px solid var(--sdt-today-bg, #286090);\n  }\n  .sdt-today-btn[disabled].s-5BcMZRcOchej {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n  .sdt-today-btn.s-5BcMZRcOchej:focus,\n  .sdt-today-btn.s-5BcMZRcOchej:active,\n  .sdt-today-btn.s-5BcMZRcOchej:hover:not([disabled]:where(.s-5BcMZRcOchej)) {\n    background-color: var(--sdt-today-bg, #286090);\n  }\n  .sdt-clear-btn.s-5BcMZRcOchej {\n    border: 1px solid var(--sdt-clear-color, #dc3545);\n    background-color: var(--sdt-clear-bg, transparent);\n    color: var(--sdt-clear-color, #dc3545);\n  }\n  .sdt-clear-btn.s-5BcMZRcOchej:focus,\n  .sdt-clear-btn.s-5BcMZRcOchej:active:not([disabled]:where(.s-5BcMZRcOchej)),\n  .sdt-clear-btn.s-5BcMZRcOchej:hover:not([disabled]:where(.s-5BcMZRcOchej)) {\n    background-color: var(--sdt-clear-hover-bg, #dc3545);\n    color: var(--sdt-clear-hover-color, var(--sdt-bg-main, #fff));\n  }\n  .sdt-widget.s-5BcMZRcOchej + .sdt-widget:where(.s-5BcMZRcOchej):before {\n    content: '';\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 50%;\n    width: 1px;\n    background-color: #eee;\n  }\n  @media screen and (max-width: 560px) {\n    .std-calendar-wrap.std-calendar-wrap.is-range-wrap.s-5BcMZRcOchej {\n      width: 280px;\n    }\n    .sdt-widget-wrap.s-5BcMZRcOchej {\n      flex-wrap: wrap;\n    }\n    .sdt-widget.s-5BcMZRcOchej + .sdt-widget:where(.s-5BcMZRcOchej):before {\n      content: none;\n    }\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHR5UGlja2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJTdmVsdHlQaWNrZXIuc3ZlbHRlIl19 */"
};
function SveltyPicker($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, SveltyPicker);
  append_styles($$anchor, $$css3);
  const pickerVisible = mutable_state();
  const parsedStartDate = mutable_state();
  const parsedEndDate = mutable_state();
  const isTodayDisabled = mutable_state();
  const fadeFn = mutable_state();
  const widgetList = mutable_state();
  const resolvedMode = mutable_state();
  const autocloseSupported = mutable_state();
  const doAutoCommit = mutable_state();
  const internalVisibility = mutable_state();
  const positionPopup = mutable_state();
  const isDirty = mutable_state();
  let inputId = prop($$props, "inputId", 8, "");
  let name = prop($$props, "name", 8, "date");
  let disabled = prop($$props, "disabled", 8, false);
  let placeholder = prop($$props, "placeholder", 8, null);
  let required = prop($$props, "required", 8, false);
  let value = prop($$props, "value", 12, null);
  let initialDate = prop($$props, "initialDate", 8, null);
  let isRange = prop($$props, "isRange", 8, false);
  let startDate = prop($$props, "startDate", 8, null);
  let endDate = prop($$props, "endDate", 8, null);
  let pickerOnly = prop($$props, "pickerOnly", 8, false);
  let startView = prop($$props, "startView", 12, MODE_MONTH);
  let mode = prop($$props, "mode", 8, "auto");
  let disableDatesFn = prop($$props, "disableDatesFn", 8, null);
  let manualInput = prop($$props, "manualInput", 8, false);
  let theme = prop($$props, "theme", 24, () => config.theme);
  let format = prop($$props, "format", 24, () => config.format);
  let formatType = prop($$props, "formatType", 24, () => config.formatType);
  let displayFormat = prop($$props, "displayFormat", 24, () => config.displayFormat);
  let displayFormatType = prop($$props, "displayFormatType", 24, () => config.displayFormatType);
  let minuteIncrement = prop($$props, "minuteIncrement", 24, () => config.minuteIncrement);
  let weekStart = prop($$props, "weekStart", 24, () => config.weekStart);
  let inputClasses = prop($$props, "inputClasses", 24, () => config.inputClasses);
  let todayBtnClasses = prop($$props, "todayBtnClasses", 24, () => config.todayBtnClasses);
  let clearBtnClasses = prop($$props, "clearBtnClasses", 24, () => config.clearBtnClasses);
  let todayBtn = prop($$props, "todayBtn", 24, () => config.todayBtn);
  let clearBtn = prop($$props, "clearBtn", 24, () => config.clearBtn);
  let clearToggle = prop($$props, "clearToggle", 24, () => config.clearToggle);
  let autocommit = prop($$props, "autocommit", 24, () => config.autocommit);
  let hourOnly = prop($$props, "hourOnly", 24, () => config.hourOnly);
  let i18n = prop($$props, "i18n", 24, () => config.i18n);
  let validatorAction = prop($$props, "validatorAction", 8, null);
  let ce_valueElement = prop($$props, "ce_valueElement", 12, null);
  let ce_displayElement = prop($$props, "ce_displayElement", 12, null);
  let positionResolver = prop($$props, "positionResolver", 8, usePosition);
  const dispatch = createEventDispatcher();
  let tmp = initProps(value(), initialDate(), format(), i18n(), formatType()), valueArray = mutable_state(tmp.valueArray), prevValue = tmp.prevValue, innerDates = mutable_state(tmp.innerDates);
  if (!value() && initialDate()) value(isRange() ? get(valueArray) : get(valueArray)[0]);
  let currentFormat = format();
  let isFocused = mutable_state(pickerOnly());
  let undoHistory = [...get(valueArray)];
  let currentValue = computeStringValue();
  let displayValue = mutable_state(computeDisplayValue());
  let calendarHoverDate = mutable_state();
  let currentMode = mutable_state(strict_equals(startView(), STARTVIEW_TIME) ? "time" : "date");
  let isMinuteView = false;
  let ref_input = mutable_state(ce_displayElement());
  let inputAction = validatorAction() ? validatorAction().shift() : () => {
  };
  let inputActionParams = validatorAction() || [];
  let ref_calendar = mutable_state();
  let eventType = mutable_state();
  function computeAutoclose(autoCommit, isRange2, resolvedMode2, eventType2, valueArray2, hourOnly2) {
    if (!autoCommit) return false;
    if (isRange2 && (strict_equals(resolvedMode2, "datetime") || strict_equals(valueArray2.length, 2, false))) return false;
    return strict_equals(eventType2, "minute") || strict_equals(resolvedMode2, eventType2) || hourOnly2 && strict_equals(eventType2, "hour");
  }
  function watchValueChange(valueArray2) {
    if (strict_equals(valueArray2.join(""), prevValue.join(""), false)) {
      set(innerDates, valueArray2.filter((e) => e).map((val) => parseDate(val, format(), i18n(), formatType())));
      prevValue = valueArray2;
      currentValue = computeStringValue();
      set(displayValue, computeDisplayValue());
    }
  }
  function watchExternalValueChange(passedValue) {
    const stringValue = Array.isArray(passedValue) ? passedValue.join(",") : passedValue;
    if (strict_equals(currentValue, stringValue, false)) {
      set(valueArray, (stringValue || "").split(","));
      undoHistory = get(valueArray);
    }
  }
  function watchFormatChange(format2, displayFormat2) {
    if (strict_equals(currentFormat, format2, false) && get(innerDates).length) {
      set(valueArray, get(innerDates).map((date) => formatDate(date, format2, i18n(), formatType())));
      prevValue = get(valueArray);
      set(displayValue, computeDisplayValue());
      currentFormat = format2;
      if (strict_equals(mode(), "auto")) {
        set(resolvedMode, format2.match(/g|hh?|ii?/i) && format2.match(/y|m|d/i) ? "datetime" : format2.match(/g|hh?|ii?/i) ? "time" : "date");
      }
      currentValue = computeStringValue();
      onValueSet(true);
    }
  }
  function computeDisplayValue() {
    return get(innerDates).sort((date1, date2) => date1 - date2).map((innerDate) => formatDate(innerDate, displayFormat() || format(), i18n(), displayFormatType() || formatType())).join(" - ");
  }
  function computeValue() {
    return isRange() ? strict_equals(get(valueArray).length, 2) ? get(valueArray) : null : get(valueArray)[0] || null;
  }
  function computeStringValue() {
    return get(valueArray).join(",");
  }
  function computeDirty(values) {
    return strict_equals(values.join(","), undoHistory.join(","), false);
  }
  function resetView() {
    startView(MODE_MONTH);
    isMinuteView = false;
    if (strict_equals(get(resolvedMode), "datetime")) {
      setTimeout(
        () => {
          if (!pickerOnly()) set(pickerVisible, false);
          set(currentMode, "date");
        },
        autocommit() ? 300 : 0
      );
    } else {
      if (!pickerOnly()) set(pickerVisible, false);
    }
  }
  function watchIsRange(isRange2) {
    return isRange2 ? [{ ref: null }, { ref: null }] : [{ ref: null }];
  }
  function watchEventType(eventType2, lastTimeId) {
    if (strict_equals(eventType2, "date") && strict_equals(get(resolvedMode), "datetime") && (isRange() && strict_equals(get(valueArray).length, 2) || !isRange())) {
      set(currentMode, "time");
    } else if (strict_equals(eventType2, "hour") && !hourOnly()) {
      get(widgetList)[lastTimeId].ref.showMinuteView();
    } else if (strict_equals(eventType2, "minute") && !isRange() && strict_equals(get(resolvedMode), "datetime") && get(doAutoCommit)) {
    }
  }
  function onDate({ type, detail }) {
    let { value: value2, isKeyboard, dateIndex } = detail;
    if (value2 && !isRange() && get(innerDates).length) {
      if (strict_equals(get(innerDates)[0].getFullYear(), value2.getFullYear()) && strict_equals(get(innerDates)[0].getMonth(), value2.getMonth()) && strict_equals(get(innerDates)[0].getDate(), value2.getDate()) && strict_equals(get(resolvedMode), "date") && !required() && clearToggle()) value2 = null;
    }
    if (isRange()) {
      if (strict_equals(type, "date")) {
        set(innerDates, value2 ? (strict_equals(get(innerDates).length, 2) ? [value2] : get(innerDates).concat(value2)).map((date) => date.getTime()).sort().map((ts) => new Date(ts)) : []);
      } else if (value2 && strict_equals(dateIndex, void 0, false)) {
        mutate(innerDates, get(innerDates)[dateIndex] = value2);
      } else if (strict_equals(type, "datetime")) {
        mutate(innerDates, get(innerDates)[0] = value2);
        mutate(innerDates, get(innerDates)[1] = value2);
      } else {
        throw new Error(`Unhandled event type: '${type}'`);
      }
      set(valueArray, get(innerDates).map((date) => formatDate(date, format(), i18n(), formatType())));
    } else {
      set(innerDates, value2 ? [value2] : []);
      set(valueArray, value2 ? [
        formatDate(value2, format(), i18n(), formatType())
      ] : []);
    }
    if (!isKeyboard) {
      set(eventType, type);
      watchEventType(type, dateIndex || 0);
    }
    tick().then(() => get(doAutoCommit) && onValueSet(!isKeyboard));
  }
  function onValueSet(doResetView) {
    value(computeValue());
    currentValue = computeStringValue();
    undoHistory = [...get(valueArray)];
    set(displayValue, computeDisplayValue());
    set(isDirty, computeDirty(get(valueArray)));
    dispatchInputEvent(true);
    dispatch("change", isRange() ? get(valueArray) : get(valueArray)[0] || null);
    dispatch("dateChange", {
      value: isRange() ? get(valueArray) : get(valueArray)[0] || null,
      dateValue: isRange() ? get(innerDates) : get(innerDates)[0] || null,
      displayValue: get(displayValue),
      valueFormat: format(),
      displayFormat: displayFormat()
    });
    doResetView && resetView();
  }
  function onToday() {
    const now = /* @__PURE__ */ new Date();
    const innerDate = get(innerDates)[0] || now;
    onDate(new CustomEvent(get(resolvedMode), {
      detail: {
        dateIndex: 0,
        value: new Date(now.getFullYear(), now.getMonth(), now.getDate(), isRange() ? 0 : innerDate.getHours(), isRange() ? 0 : innerDate.getMinutes(), 0),
        isKeyboard: false
      }
    }));
    if (isRange()) {
      onDate(new CustomEvent(get(resolvedMode), {
        detail: {
          dateIndex: 1,
          value: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999),
          isKeyboard: false
        }
      }));
    }
    onValueSet(true);
  }
  function onClear() {
    set(valueArray, []);
    prevValue = [];
    set(innerDates, []);
    currentValue = "";
    autocommit() && onValueSet();
  }
  function onCancel() {
    set(valueArray, [...undoHistory]);
    currentValue = computeStringValue();
    resetView();
    dispatch("cancel");
  }
  function onKeyDown(e) {
    if (!get(pickerVisible)) {
      ["Backspace", "Delete"].includes(e.key) && !required() && onClear();
      if (strict_equals(e.key, "Enter")) onInputFocus();
    }
    if (!get(pickerVisible) && strict_equals(e.key, "Tab", false)) {
      set(pickerVisible, strict_equals(e.key, "Shift", false));
      e.preventDefault();
      return;
    }
    switch (e.key) {
      case "PageDown":
      case "PageUp":
      case "ArrowDown":
      case "ArrowUp":
      case "ArrowLeft":
      case "ArrowRight":
        e.preventDefault();
        if (isRange()) return;
        if (strict_equals(get(currentMode), "date")) {
          get(ref_calendar).handleGridNav(e.key, e.shiftKey);
        } else {
          get(widgetList)[0].ref.makeTick(["ArrowDown", "ArrowLeft", "PageDown"].includes(e.key) ? -1 : 1);
        }
        break;
      case "Escape":
        autocommit() ? onClear() : onCancel();
        break;
      case "Backspace":
        if (manualInput() && !isRange()) return;
      case "Delete":
        !required() && onClear();
        break;
      case "Enter":
        get(isFocused) && e.preventDefault();
        if (strict_equals(get(valueArray).length, 0)) {
          set(pickerVisible, false);
          return;
        }
        if (strict_equals(get(currentMode), "time") && !isMinuteView) {
          return get(widgetList)[0].ref.showMinuteView();
        }
        if (strict_equals(get(resolvedMode), "datetime") && strict_equals(get(currentMode), "time", false)) {
          set(currentMode, "time");
          return;
        }
        onValueSet(strict_equals(get(resolvedMode), "date") || get(resolvedMode).includes("time") && isMinuteView);
        break;
      case "Tab":
        if (get(pickerVisible)) {
          set(
            pickerVisible,
            // just temporary
            false
          );
          e.preventDefault();
        }
      case "F5":
        break;
      default:
        !manualInput() && e.preventDefault();
    }
  }
  function onManualInput(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    const parsedInput = parseDate(event2.target.value, displayFormat() || format(), i18n(), displayFormatType() || formatType());
    const formattedInput = formatDate(parsedInput, displayFormat() || format(), i18n(), displayFormatType() || formatType());
    if (strict_equals(formattedInput, event2.target.value)) {
      onDate(new CustomEvent("date", {
        detail: { value: parsedInput, isKeyboard: true }
      }));
    }
  }
  function onModeSwitch(e) {
    startView(MODE_MONTH);
    set(currentMode, e.detail);
    isMinuteView = false;
  }
  function onInputFocus() {
    set(isFocused, true);
    set(pickerVisible, true);
  }
  function onInputBlur() {
    set(isFocused, false);
    get(autocloseSupported) ? onValueSet(false) : onCancel();
    !ce_displayElement() && dispatch("blur");
  }
  function dispatchInputEvent(dispatchInputEvent2) {
    if (ce_valueElement() && ce_displayElement()) {
      ce_valueElement(ce_valueElement().value = get(valueArray).join(",") || "", true);
      ce_displayElement(ce_displayElement().value = get(displayValue), true);
      ce_valueElement().dispatchEvent(new Event("input"));
      ce_displayElement().dispatchEvent(new Event("input"));
    }
    dispatchInputEvent2 && dispatch("input", currentValue);
  }
  function updateCalendarHoverDate({ detail }) {
    set(calendarHoverDate, detail);
  }
  function onTimeSwitch(e) {
    isMinuteView = e.detail;
  }
  onMount(() => {
    if (ce_displayElement()) {
      ce_displayElement(ce_displayElement().onfocus = onInputFocus, true);
      ce_displayElement(ce_displayElement().onblur = onInputBlur, true);
      ce_displayElement(ce_displayElement().onclick = () => !get(pickerVisible) && onInputFocus(), true);
      ce_displayElement(ce_displayElement().onkeydown = onKeyDown, true);
    }
  });
  legacy_pre_effect(() => deep_read_state(pickerOnly()), () => {
    set(pickerVisible, pickerOnly());
  });
  legacy_pre_effect(
    () => (deep_read_state(startDate()), parseDate, deep_read_state(format()), deep_read_state(i18n()), deep_read_state(formatType())),
    () => {
      set(parsedStartDate, startDate() ? parseDate(startDate(), format(), i18n(), formatType()) : null);
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(endDate()), parseDate, deep_read_state(format()), deep_read_state(i18n()), deep_read_state(formatType())),
    () => {
      set(parsedEndDate, endDate() ? new Date(parseDate(endDate(), format(), i18n(), formatType()).setSeconds(1)) : null);
    }
  );
  legacy_pre_effect(
    () => (get(parsedStartDate), get(parsedEndDate)),
    () => {
      set(isTodayDisabled, get(parsedStartDate) && get(parsedStartDate) > /* @__PURE__ */ new Date() || get(parsedEndDate) && get(parsedEndDate) < /* @__PURE__ */ new Date());
    }
  );
  legacy_pre_effect(() => (deep_read_state(pickerOnly()), fade), () => {
    set(fadeFn, pickerOnly() ? () => ({}) : fade);
  });
  legacy_pre_effect(() => deep_read_state(isRange()), () => {
    set(widgetList, watchIsRange(isRange()));
  });
  legacy_pre_effect(
    () => (computeResolvedMode, deep_read_state(mode()), deep_read_state(format())),
    () => {
      set(resolvedMode, computeResolvedMode(mode(), format()));
    }
  );
  legacy_pre_effect(
    () => (get(resolvedMode), get(currentMode)),
    () => {
      if (strict_equals(get(resolvedMode), "time") && strict_equals(get(currentMode), get(resolvedMode), false)) {
        set(currentMode, get(resolvedMode));
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(autocommit()), deep_read_state(isRange()), get(resolvedMode)),
    () => {
      set(autocloseSupported, autocommit() && (isRange() && strict_equals(get(resolvedMode), "date") || !isRange()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(autocommit()), deep_read_state(isRange()), get(resolvedMode), get(eventType), get(valueArray), deep_read_state(hourOnly())),
    () => {
      set(doAutoCommit, computeAutoclose(autocommit(), isRange(), get(resolvedMode), get(eventType), get(valueArray), hourOnly()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(ce_displayElement()), get(isFocused)),
    () => {
      if (ce_displayElement()) ce_displayElement(ce_displayElement().readOnly = get(isFocused), true);
    }
  );
  legacy_pre_effect(() => deep_read_state(pickerOnly()), () => {
    set(internalVisibility, pickerOnly() ? true : false);
  });
  legacy_pre_effect(
    () => (deep_read_state(pickerOnly()), deep_read_state(positionResolver())),
    () => {
      set(positionPopup, !pickerOnly() ? positionResolver() : () => {
      });
    }
  );
  legacy_pre_effect(() => get(valueArray), () => {
    set(isDirty, computeDirty(get(valueArray)));
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    watchExternalValueChange(value());
  });
  legacy_pre_effect(() => get(valueArray), () => {
    watchValueChange(get(valueArray));
  });
  legacy_pre_effect(
    () => (deep_read_state(format()), deep_read_state(displayFormat())),
    () => {
      watchFormatChange(format(), displayFormat());
    }
  );
  legacy_pre_effect_reset();
  init();
  var span = root3();
  var node = child(span);
  slot(
    node,
    $$props,
    "inputs",
    {
      get value() {
        return value();
      },
      get displayValue() {
        return get(displayValue);
      },
      get disabled() {
        return disabled();
      },
      get isDirty() {
        return get(isDirty);
      },
      onKeyDown,
      onInputFocus,
      onInputBlur
    },
    ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      if_block(node_1, () => !ce_displayElement(), ($$anchor3) => {
        var fragment_1 = root_23();
        var input = first_child(fragment_1);
        remove_input_defaults(input);
        var node_2 = sibling(input, 2);
        if_block(node_2, () => !pickerOnly(), ($$anchor4) => {
          var input_1 = root_33();
          remove_input_defaults(input_1);
          template_effect(() => set_attribute(input_1, "name", name().endsWith("]") ? name().substring(0, name().length - 1) + "_input]" : name() + "_input"));
          bind_this(input_1, ($$value) => set(ref_input, $$value), () => get(ref_input));
          effect(() => event("input", input_1, function(...$$args) {
            apply(() => manualInput() ? onManualInput : () => {
            }, this, $$args, SveltyPicker, [564, 16]);
          }));
          action(input_1, ($$node, $$action_arg) => inputAction($$node, $$action_arg), () => inputActionParams);
          effect(() => event("focus", input_1, onInputFocus));
          effect(() => event("blur", input_1, onInputBlur));
          effect(() => event("click", input_1, () => {
            !get(pickerVisible) && onInputFocus();
          }));
          effect(() => event("input", input_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          }));
          effect(() => event("change", input_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          }));
          effect(() => event("keydown", input_1, onKeyDown));
          template_effect(() => {
            set_attribute(input_1, "id", inputId());
            set_value(input_1, get(displayValue));
            set_attribute(input_1, "placeholder", placeholder());
            input_1.disabled = disabled();
            input_1.required = required();
            set_attribute(input_1, "inputmode", manualInput() ? "text" : "none");
            set_class(input_1, `${inputClasses() ?? ""} s-5BcMZRcOchej`);
            input_1.readOnly = get(isFocused) && !manualInput() && !isRange();
            toggle_class(input_1, "value-dirty", !autocommit() && get(isDirty));
          });
          append($$anchor4, input_1);
        });
        template_effect(() => {
          set_attribute(input, "name", name());
          set_value(input, value());
        });
        append($$anchor3, fragment_1);
      });
      append($$anchor2, fragment);
    }
  );
  var node_3 = sibling(node, 2);
  if_block(node_3, () => get(pickerVisible) && get(isFocused), ($$anchor2) => {
    var div = root_43();
    var div_1 = child(div);
    each(div_1, 5, () => get(widgetList), index, ($$anchor3, w, i) => {
      var div_2 = root_53();
      var node_4 = child(div_2);
      if_block(
        node_4,
        () => strict_equals(get(currentMode), "date"),
        ($$anchor4) => {
          var fragment_2 = comment();
          var node_5 = first_child(fragment_2);
          var enableTimeToggle = derived_safe_equal(() => {
            var _a;
            return (_a = get(resolvedMode)) == null ? void 0 : _a.includes("time");
          });
          var initialView = derived_safe_equal(() => startView() > 2 ? 2 : startView());
          bind_this(
            Calendar_default(node_5, {
              wid: i,
              get dates() {
                return get(innerDates);
              },
              get isRange() {
                return isRange();
              },
              get startDate() {
                return get(parsedStartDate);
              },
              get endDate() {
                return get(parsedEndDate);
              },
              get enableTimeToggle() {
                return get(enableTimeToggle);
              },
              get initialView() {
                return get(initialView);
              },
              get hoverDate() {
                return get(calendarHoverDate);
              },
              get additionalDisableFn() {
                return disableDatesFn();
              },
              get i18n() {
                return i18n();
              },
              get weekStart() {
                return weekStart();
              },
              $$events: {
                date: onDate,
                switch: onModeSwitch,
                internal_hoverUpdate: updateCalendarHoverDate
              },
              $$legacy: true
            }),
            ($$value) => set(ref_calendar, $$value),
            () => get(ref_calendar)
          );
          append($$anchor4, fragment_2);
        },
        ($$anchor4) => {
          var fragment_3 = comment();
          var node_6 = first_child(fragment_3);
          var hasDateComponent = derived_safe_equal(() => strict_equals(get(resolvedMode), "time", false));
          var showMeridian = derived_safe_equal(() => strict_equals(format().match(strict_equals(formatType(), "php") ? "a|A" : "p|P"), null, false));
          bind_this(
            Time_default(node_6, {
              wid: i,
              get date() {
                return get(innerDates)[i];
              },
              get startDate() {
                return get(parsedStartDate);
              },
              get endDate() {
                return get(parsedEndDate);
              },
              get hasDateComponent() {
                return get(hasDateComponent);
              },
              get showMeridian() {
                return get(showMeridian);
              },
              get i18n() {
                return i18n();
              },
              get minuteIncrement() {
                return minuteIncrement();
              },
              get hourOnly() {
                return hourOnly();
              },
              $$events: {
                hour: onDate,
                minute: onDate,
                switch: onModeSwitch,
                "time-switch": onTimeSwitch
              },
              $$legacy: true
            }),
            ($$value, w2) => (w2.ref = $$value, invalidate_inner_signals(() => (get(widgetList), watchIsRange, isRange()))),
            (w2) => w2 == null ? void 0 : w2.ref,
            () => [get(w)]
          );
          append($$anchor4, fragment_3);
        }
      );
      reset(div_2);
      append($$anchor3, div_2);
    });
    reset(div_1);
    var node_7 = sibling(div_1, 2);
    slot(
      node_7,
      $$props,
      "action-row",
      {
        onCancel,
        onConfirm: () => onValueSet(true),
        onClear,
        onToday,
        get isTodayDisabled() {
          return get(isTodayDisabled);
        },
        get currentMode() {
          return get(currentMode);
        },
        get i18n() {
          return i18n();
        }
      },
      ($$anchor3) => {
        var fragment_4 = comment();
        var node_8 = first_child(fragment_4);
        if_block(node_8, () => !get(autocloseSupported) || true, ($$anchor4) => {
          var div_3 = root_92();
          var node_9 = child(div_3);
          if_block(node_9, () => !get(autocloseSupported), ($$anchor5) => {
            var span_1 = root_102();
            var button = child(span_1);
            var text = child(button, true);
            reset(button);
            var button_1 = sibling(button, 2);
            var text_1 = child(button_1, true);
            reset(button_1);
            reset(span_1);
            template_effect(() => {
              set_class(button, `${clearBtnClasses() ?? ""} s-5BcMZRcOchej`);
              set_text(text, i18n().cancelBtn);
              set_class(button_1, `${todayBtnClasses() ?? ""} s-5BcMZRcOchej`);
              set_text(text_1, i18n().okBtn);
            });
            event("click", button, onCancel);
            event("click", button_1, () => onValueSet(true));
            append($$anchor5, span_1);
          });
          var node_10 = sibling(node_9, 2);
          if_block(node_10, () => todayBtn() || clearBtn(), ($$anchor5) => {
            var span_2 = root_112();
            var node_11 = child(span_2);
            if_block(node_11, () => todayBtn() && strict_equals(get(currentMode), "date"), ($$anchor6) => {
              var button_2 = root_122();
              var text_2 = child(button_2, true);
              reset(button_2);
              template_effect(() => {
                set_class(button_2, `${todayBtnClasses() ?? ""} s-5BcMZRcOchej`);
                button_2.disabled = get(isTodayDisabled);
                set_text(text_2, i18n().todayBtn);
              });
              event("click", button_2, onToday);
              append($$anchor6, button_2);
            });
            var node_12 = sibling(node_11, 2);
            if_block(node_12, clearBtn, ($$anchor6) => {
              var button_3 = root_13();
              var text_3 = child(button_3, true);
              reset(button_3);
              template_effect(() => {
                set_class(button_3, `${clearBtnClasses() ?? ""} s-5BcMZRcOchej`);
                set_text(text_3, i18n().clearBtn);
              });
              event("click", button_3, onClear);
              append($$anchor6, button_3);
            });
            reset(span_2);
            append($$anchor5, span_2);
          });
          reset(div_3);
          append($$anchor4, div_3);
        });
        append($$anchor3, fragment_4);
      }
    );
    reset(div);
    action(div, ($$node) => get(positionPopup)($$node));
    effect(() => event("mousedown", div, preventDefault(function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    })));
    template_effect(() => {
      set_class(div, `std-calendar-wrap ${theme() ?? ""} s-5BcMZRcOchej`);
      toggle_class(div, "is-popup", !get(internalVisibility));
      toggle_class(div, "is-range-wrap", isRange());
    });
    transition(3, div, () => get(fadeFn), () => ({ duration: 200 }));
    append($$anchor2, div);
  });
  reset(span);
  append($$anchor, span);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SveltyPicker = hmr(SveltyPicker, () => SveltyPicker[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-5BcMZRcOchej");
    module.default[HMR].source = SveltyPicker[HMR].source;
    set(SveltyPicker[HMR].source, module.default[HMR].original);
  });
}
var SveltyPicker_default = SveltyPicker;
mark_module_end(SveltyPicker);

// node_modules/svelty-picker/dist/index.js
var dist_default = SveltyPicker_default;
export {
  config,
  dist_default as default,
  formatDate,
  parseDate
};
//# sourceMappingURL=svelty-picker.js.map
